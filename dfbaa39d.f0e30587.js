(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{78:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return c}));var r=n(2),a=(n(0),n(89));const o={title:"Using Resolvers"},i={unversionedId:"resolver/using-resolvers",id:"resolver/using-resolvers",isDocsHomePage:!1,title:"Using Resolvers",description:"Resolvers are functions that make up the basis for how data is determined in resolving queries in GraphQL APIs. There",source:"@site/docs/resolver/using-resolvers.md",slug:"/resolver/using-resolvers",permalink:"/docs/resolver/using-resolvers",version:"current",sidebar:"docs",previous:{title:"Concepts",permalink:"/docs/concepts"},next:{title:"Introducing Resolver Wrappers",permalink:"/docs/resolver/introducing-wrappers"}},l=[{value:"Field Resolvers",id:"field-resolvers",children:[{value:"Root (Query and Mutation) Field Resolvers",id:"root-query-and-mutation-field-resolvers",children:[]},{value:"Non-Root Field Resolvers",id:"non-root-field-resolvers",children:[]},{value:"Default Field Resolver",id:"default-field-resolver",children:[]},{value:"<code>parent</code> parameter (first)",id:"parent-parameter-first",children:[]},{value:"<code>arg</code> parameter (second)",id:"arg-parameter-second",children:[]},{value:"<code>context</code> parameter (third)",id:"context-parameter-third",children:[]},{value:"<code>info</code> parameter (fourth)",id:"info-parameter-fourth",children:[]}]},{value:"Type Resolvers",id:"type-resolvers",children:[{value:"<code>value</code> parameter (first)",id:"value-parameter-first",children:[]},{value:"<code>context</code> parameter (second)",id:"context-parameter-second",children:[]},{value:"<code>info</code> parameter (third)",id:"info-parameter-third",children:[]},{value:"<code>abstractType</code> parameter (fourth)",id:"abstracttype-parameter-fourth",children:[]},{value:"Default Type Resolver",id:"default-type-resolver",children:[]}]},{value:"Organizing Resolvers for Executing GraphQL queries",id:"organizing-resolvers-for-executing-graphql-queries",children:[]},{value:"Extending Resolvers with Resolver Wrappers",id:"extending-resolvers-with-resolver-wrappers",children:[]},{value:"Additional Resources",id:"additional-resources",children:[]}],s={rightToc:l};function c({components:e,...t}){return Object(a.b)("wrapper",Object(r.a)({},s,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Resolvers are functions that make up the basis for how data is determined in ",Object(a.b)("em",{parentName:"p"},"resolving")," queries in GraphQL APIs. There\nare two types of resolvers, ",Object(a.b)("em",{parentName:"p"},"Field Resolvers")," and ",Object(a.b)("em",{parentName:"p"},"Type Resolvers"),". ",Object(a.b)("em",{parentName:"p"},"Field Resolvers")," represent the specific data\nreturned within the ",Object(a.b)("inlineCode",{parentName:"p"},"data")," key a result payload. ",Object(a.b)("em",{parentName:"p"},"Type Resolvers")," are responsible for taking an Abstract Type (GraphQL\nUnion or Interface types) and returning a string representing the concrete type."),Object(a.b)("h2",{id:"field-resolvers"},"Field Resolvers"),Object(a.b)("p",null,"Field resolvers are represented by the following function:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"async function (parent, args, context, info) {\n  return data;\n}\n")),Object(a.b)("p",null,"The majority of the time when Resolvers are mentioned in a GraphQL context it is referring to ",Object(a.b)("em",{parentName:"p"},"Field Resolvers"),". Field\nResolvers are responsible for returning the ",Object(a.b)("inlineCode",{parentName:"p"},"data")," specified by the GraphQL Schema (or a ",Object(a.b)("inlineCode",{parentName:"p"},"Promise")," of the data). Check\nout the ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.apollographql.com/docs/apollo-server/data/resolvers/"}),"apollo documentation on resolvers"),", too, it\napplies here and to GraphQL in general."),Object(a.b)("p",null,"With the given schema:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),'schema {\n  # denotes the "Root Query Type" as the "Query" type\n  query: Query\n}\n\n# "Query" is the "Root Query Type" as denoted by the schema definition\ntype Query {\n  # root field that returns an "Actor"\n  actor: Actor!\n}\n\ntype Actor {\n  name: String!\n}\n')),Object(a.b)("p",null,"This schema would have two resolvers:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},'One "root field resolver" on the ',Object(a.b)("inlineCode",{parentName:"li"},"Query")," type for the ",Object(a.b)("inlineCode",{parentName:"li"},"actor")," field"),Object(a.b)("li",{parentName:"ul"},'One "non-root field resolver" on the ',Object(a.b)("inlineCode",{parentName:"li"},"Actor")," type for the ",Object(a.b)("inlineCode",{parentName:"li"},"name")," field")),Object(a.b)("h3",{id:"root-query-and-mutation-field-resolvers"},"Root (Query and Mutation) Field Resolvers"),Object(a.b)("p",null,'All GraphQL queries start with a "root" field. Root Field Resolvers are either on the root ',Object(a.b)("inlineCode",{parentName:"p"},"Query")," type or the root\n",Object(a.b)("inlineCode",{parentName:"p"},"Mutation"),' type depending on whether it\'s a query or mutation operation, respectively. These root resolvers "kick off"\nthe query and being at the "root" typically have a ',Object(a.b)("inlineCode",{parentName:"p"},"null")," parent argument (unless one has been explicitly declared)."),Object(a.b)("p",null,"A root resolver function for the ",Object(a.b)("inlineCode",{parentName:"p"},"actor")," field could be:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'async function (parent, args, context, info) {\n  return {\n    name: "Meryl Streep"\n  };\n}\n')),Object(a.b)("h3",{id:"non-root-field-resolvers"},"Non-Root Field Resolvers"),Object(a.b)("p",null,"Any type is that not the root Query type or the root Mutation type will be a type that contains non-root field\nresolvers. In this case they are ",Object(a.b)("em",{parentName:"p"},"connected to the graph")," through some reference to the root Query and Mutation types.\nDue to the graph-like nature of resolving queries these non-root fields and their resolvers can be referenced multiple\ntimes and as such often rely on the ",Object(a.b)("inlineCode",{parentName:"p"},"parent")," parameters to understand their connection in the graph."),Object(a.b)("p",null,"The ",Object(a.b)("em",{parentName:"p"},"non-root field")," on ",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," is ",Object(a.b)("inlineCode",{parentName:"p"},"name"),". When any type resolves an ",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," type each of the field resolvers receives\nthe parent and is responsible for returning a result for their field."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"name")," field resolver on the ",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," type could look like:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"async function (parent, args, context, info) {\n  return parent.name;\n}\n")),Object(a.b)("p",null,"This example looks for the ",Object(a.b)("inlineCode",{parentName:"p"},"name")," property on the parent. In this case the ",Object(a.b)("inlineCode",{parentName:"p"},"parent")," was:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-json"}),'{\n  "name": "Meryl Streep"\n}\n')),Object(a.b)("p",null,"The returned value is ",Object(a.b)("inlineCode",{parentName:"p"},'"Meryl Streep"')," which matches the return value of ",Object(a.b)("inlineCode",{parentName:"p"},"String!")," set by the ",Object(a.b)("inlineCode",{parentName:"p"},"name")," field on the\n",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," type."),Object(a.b)("p",null,"Now, to show the flexible nature of resolvers lets expand the the ",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," type:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"type Actor {\n  name: String!\n  favoriteActor: Actor\n}\n")),Object(a.b)("p",null,"Here we have the ",Object(a.b)("inlineCode",{parentName:"p"},"favoriteActor")," of an ",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," being ",Object(a.b)("strong",{parentName:"p"},"another ",Object(a.b)("inlineCode",{parentName:"strong"},"Actor")),". This demonstrates the how types can reference\neach other and resolver functions have to be able to return the relevant data whether called from a Root Query or Root\nMutation type, or from another type, or the same type itself."),Object(a.b)("p",null,"If Tom Hanks was Meryl Streep's favorite actor the ",Object(a.b)("inlineCode",{parentName:"p"},"favoriteActor")," resolver could look like:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'async function (parent, args, context, info) {\n  if (parent.name === "Meryl Streep") {\n    return "Tom Hanks";\n  }\n\n  return null;\n}\n')),Object(a.b)("p",null,"Only when the parent ",Object(a.b)("inlineCode",{parentName:"p"},"Actor")," has a name of ",Object(a.b)("inlineCode",{parentName:"p"},'"Meryl Streep"')," do we return ",Object(a.b)("inlineCode",{parentName:"p"},'"Tom Hanks"')," in other cases we will return\n",Object(a.b)("inlineCode",{parentName:"p"},"null")," for all other ",Object(a.b)("inlineCode",{parentName:"p"},"Actor"),"s. This could be quite tedious to manage all the favorite actors from a single resolver so\nit is usually best practice to have a data source or a well-referenced look-up that can be used. Typically, the parent\nalso has an ",Object(a.b)("inlineCode",{parentName:"p"},"ID")," field that can be referenced for lookup also."),Object(a.b)("h3",{id:"default-field-resolver"},"Default Field Resolver"),Object(a.b)("p",null,"It should be noted that GraphQL sets up every field with a default Field Resolver function. In fact it can be imported\nfrom the ",Object(a.b)("inlineCode",{parentName:"p"},"graphql")," package, too."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"import { defaultFieldResolver } from 'graphql';\n")),Object(a.b)("p",null,"It will attempt to resolve a field based on the a look up of the field's name on the parent. This typically a desired\nbehavior so often you don't have to write a resolver at all, graphql will do this \"out of the box\"."),Object(a.b)("p",null,"There are a couple of other things the default Field Resolver does, check out the\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/graphql/graphql-js/blob/7b3241329e1ff49fb647b043b80568f0cf9e1a7c/src/execution/execute.js#L1208-L1226"}),"source code"),",\nit's under 10 lines!"),Object(a.b)("h3",{id:"parent-parameter-first"},Object(a.b)("inlineCode",{parentName:"h3"},"parent")," parameter (first)"),Object(a.b)("p",null,"Sometimes called ",Object(a.b)("inlineCode",{parentName:"p"},"obj"),', and be named whatever you call the variable, represents the previous returned value in the\n"graph" of results. As mentioned, in root field resolvers this will typically be null since the query has just begun and\nhas no parent.'),Object(a.b)("h3",{id:"arg-parameter-second"},Object(a.b)("inlineCode",{parentName:"h3"},"arg")," parameter (second)"),Object(a.b)("p",null,"When a schema specifies arguments and those values are provided they are available on the field by its ",Object(a.b)("inlineCode",{parentName:"p"},"arg"),' parameter.\nInstead of defaulting to "Meryl Streep" what if we had a list of actors required the name to be specified and returned\nthe actor that matched.'),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"type Query {\n  # an additon of a required `name` argument to look up the actor\n  actor(name: String): Actor!\n}\n")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const actors = [ { name: 'Meryl Streep' }, { name: 'Tom Hanks' } ];\n\nasync function (parent, args, context, info) {\n  return actors.find(actor => actor.name === args.name);\n}\n")),Object(a.b)("p",null,"And the value for name can be referenced as an argument:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),'query {\n  actor(name: "Tom Hanks") {\n    name\n  }\n}\n')),Object(a.b)("p",null,"The source of this ",Object(a.b)("inlineCode",{parentName:"p"},"actors")," data is a bit hand-wavy, there are ways of accessing these data sources (typically from the\n",Object(a.b)("inlineCode",{parentName:"p"},"context")," parameter), but what is important is how arguments are passed to the field and its resolver via the ",Object(a.b)("inlineCode",{parentName:"p"},"args"),"\nparameter."),Object(a.b)("h3",{id:"context-parameter-third"},Object(a.b)("inlineCode",{parentName:"h3"},"context")," parameter (third)"),Object(a.b)("p",null,"This is the \"global\" bucket that is accessible in every resolver. It's usually an object. It's typically a good place to\nput data sources that can combined with the ",Object(a.b)("inlineCode",{parentName:"p"},"parent")," and ",Object(a.b)("inlineCode",{parentName:"p"},"args")," can be used to lookup. ",Object(a.b)("inlineCode",{parentName:"p"},"graphql-mocks")," has an opinion\napproach with a managed context to provide conventions and assist in threading the common use cases."),Object(a.b)("p",null,"For example, ",Object(a.b)("inlineCode",{parentName:"p"},"dependencies")," that are passed to the ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/getting-started/create-handler"}),"graphql-mocks GraphQL Handler"),"\ncan reliably be pulled from context using the\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"http://localhost:3000/api/modules/_resolver_extract_dependencies_.html#extractdependencies"}),Object(a.b)("inlineCode",{parentName:"a"},"extractDependencies")," function"),".\nThere are other helpful ways that context can be used with ",Object(a.b)("inlineCode",{parentName:"p"},"graphql-mocks"),", too!"),Object(a.b)("h3",{id:"info-parameter-fourth"},Object(a.b)("inlineCode",{parentName:"h3"},"info")," parameter (fourth)"),Object(a.b)("p",null,"This is mostly a holder of meta and GraphQL information. It's not usually needed but does have some handy insights into\nthe query, AST, and access to the GraphQL schema."),Object(a.b)("h2",{id:"type-resolvers"},"Type Resolvers"),Object(a.b)("p",null,"While covered less the ",Object(a.b)("inlineCode",{parentName:"p"},"resolveType")," Type Resolver function on the\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://graphql.org/graphql-js/type/#graphqlinterfacetype"}),Object(a.b)("inlineCode",{parentName:"a"},"GraphQLInterfaceType"))," and\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://graphql.org/graphql-js/type/#graphqluniontype"}),Object(a.b)("inlineCode",{parentName:"a"},"GraphQLUnionType"))," play an important role in resolving GraphQL\nqueries. See the Apollo documentation for\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.apollographql.com/docs/apollo-server/schema/unions-interfaces/"}),"additional examples"),"."),Object(a.b)("p",null,"Type Resolver functions have the following signature:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"async function (value, context, info, abstractType) {\n  return 'ResolvedTypeName';\n}\n")),Object(a.b)("p",null,'The objective for a Type Resolver is given a "value", the object in question, to determine which discrete type is\nrepresented. The return value of a Type Resolver function is a string representing the concrete type name, ie: ',Object(a.b)("inlineCode",{parentName:"p"},"Dog")," or\n",Object(a.b)("inlineCode",{parentName:"p"},"Cat")," in the following example for the ",Object(a.b)("inlineCode",{parentName:"p"},"Pet")," abstract type."),Object(a.b)("p",null,"Here's an example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"schema {\n  query: Query\n}\n\ntype Query {\n  pet: Pet!\n}\n\nunion Pet = Cat | Dog\n\ntype Cat {\n  name: String!\n}\n\ntype Dog {\n  name: String!\n  likesBones: Boolean!\n}\n")),Object(a.b)("p",null,"And our Type Resolver:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"async function (value, context, info, abstractType) {\n  if ('likesBones' in value) {\n    return 'Dog';\n  } else {\n    return 'Cat';\n  }\n}\n")),Object(a.b)("p",null,"We are given the concrete object in question and are responsible for determining which type of ",Object(a.b)("inlineCode",{parentName:"p"},"Pet")," it is: either a Pet\nis a ",Object(a.b)("inlineCode",{parentName:"p"},"Dog")," or a ",Object(a.b)("inlineCode",{parentName:"p"},"Cat"),". In this contrived example the ",Object(a.b)("inlineCode",{parentName:"p"},"likesBones")," property is checked to exist and if it does we assume\nit's a ",Object(a.b)("inlineCode",{parentName:"p"},"Dog"),". This is something to consider when working with Abstract Types (Unions and Interfaces) is how the\nunderlying concrete types will be identified. It is usually to leave a concrete type identifier ",Object(a.b)("inlineCode",{parentName:"p"},"__typename")," on the\nconcrete type which would allow the default type resolver to automatically use the value."),Object(a.b)("h3",{id:"value-parameter-first"},Object(a.b)("inlineCode",{parentName:"h3"},"value")," parameter (first)"),Object(a.b)("p",null,"The ambiguous object in question that needs to be identified to a concrete type"),Object(a.b)("h3",{id:"context-parameter-second"},Object(a.b)("inlineCode",{parentName:"h3"},"context")," parameter (second)"),Object(a.b)("p",null,"The same ",Object(a.b)("inlineCode",{parentName:"p"},"context")," ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/resolver/using-resolvers#context-parameter-third"}),"global object as represented in Field Resolvers"),"."),Object(a.b)("h3",{id:"info-parameter-third"},Object(a.b)("inlineCode",{parentName:"h3"},"info")," parameter (third)"),Object(a.b)("p",null,"Represents the meta details and GraphQL information, is usually only needed in exceptional cases."),Object(a.b)("h3",{id:"abstracttype-parameter-fourth"},Object(a.b)("inlineCode",{parentName:"h3"},"abstractType")," parameter (fourth)"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"abstractType")," is either a ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLInterfaceType")," or ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLUnionType")," and the instance provides the details of the\nabstract type that is being resolved down to a concrete type."),Object(a.b)("h3",{id:"default-type-resolver"},"Default Type Resolver"),Object(a.b)("p",null,"Similar to Field Resolvers, Type Resolvers also have a default resolver that exists on the ",Object(a.b)("inlineCode",{parentName:"p"},"resolveType")," of the\nInterface and Union types."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"import { defaultTypeResolver } from 'graphql';\n")),Object(a.b)("p",null,"The default behavior the ",Object(a.b)("inlineCode",{parentName:"p"},"defaultTypeResolver")," is to check the object for the ",Object(a.b)("inlineCode",{parentName:"p"},"__typename")," field and return the value if\nit exists, or less commonly to check ",Object(a.b)("inlineCode",{parentName:"p"},"isTypeOf")," on each on each possible type with the object being coerced. Check out\nthe\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/graphql/graphql-js/blob/d6e760cf7060217bd25fa934bd104ff2400aad96/src/execution/execute.js#L1147-L1195"}),"source code"),"\nfor more details."),Object(a.b)("h2",{id:"organizing-resolvers-for-executing-graphql-queries"},"Organizing Resolvers for Executing GraphQL queries"),Object(a.b)("p",null,'This page focuses on the Resolver functions themselves but hasn\'t shown how they are actually applied to the Fields and\nAbstract Types that they are responsible for resolving. On their own they are "just functions" and need a way of being\nassigned. This is the role of a Resolver Map which organized these Resolver Functions so that they can be applied to a\n',Object(a.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," and executed against queries and mutations, check out the\n",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/resolver-map/using-resolver-maps"}),"Resolver Map")," to understand the next step in applying Resolver functions."),Object(a.b)("h2",{id:"extending-resolvers-with-resolver-wrappers"},"Extending Resolvers with Resolver Wrappers"),Object(a.b)("p",null,"The next section will introduce Resolver Wrappers from this library and how they can be used to allow Resolvers\nfunctions to be extended."),Object(a.b)("h2",{id:"additional-resources"},"Additional Resources"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object(r.a)({parentName:"li"},{href:"https://www.apollographql.com/docs/apollo-server/data/resolvers/"}),"Apollo.js Resolver Documentation")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object(r.a)({parentName:"li"},{href:"https://graphql.org/learn/execution/"}),"Official graphql.js Query Execution Documentation"))))}c.isMDXComponent=!0},89:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),h=r,u=b["".concat(i,".").concat(h)]||b[h]||d[h]||o;return n?a.a.createElement(u,l(l({ref:t},c),{},{components:n})):a.a.createElement(u,l({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);