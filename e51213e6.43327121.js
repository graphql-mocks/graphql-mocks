(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{106:function(e,n,r){"use strict";r.d(n,"a",(function(){return i}));var a=r(0),t=r.n(a);function i(e){return t.a.createElement(t.a.Fragment,null,t.a.createElement("strong",null,"Result: "),t.a.createElement("pre",{className:"graphql-result"},JSON.stringify(e.result,null,2)))}},207:function(e,n,r){"use strict";n.a={data:{helloWorld:"Hello from my first GraphQL resolver!"}}},88:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return d})),r.d(n,"metadata",(function(){return h})),r.d(n,"rightToc",(function(){return m})),r.d(n,"default",(function(){return y}));var a=r(2),t=r(6),i=(r(0),r(91)),o=["components"],l={rightToc:[]};function s(e){var n=e.components,r=Object(t.a)(e,o);return Object(i.b)("wrapper",Object(a.a)({},l,r,{components:n,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'// This example is assuming you already have a GraphQL resolver map and have an\n// existing handler (in this case via graphql-tools). If this is not the case\n// check out the "Creating a GraphQL Handler" documentation section to create a GraphQL\n// handler with `graphql-mocks`.\nimport { makeExecutableSchema } from "graphql-tools";\nimport { buildSchema, graphql, printSchema } from "graphql";\nimport { pack } from "graphql-mocks/pack";\n\nasync function run() {\n  const graphqlSchema = buildSchema(`\n    schema {\n      query: Query\n    }\n\n    type Query {\n      helloWorld: String!\n    }\n  `);\n\n  // This represents the original resolver map being used by your existing GraphQL\n  // handler and is needed for the `pack` function to apply Resolver Map\n  // Middlewares and Resolver Wrappers.\n  const resolverMap = {\n    Query: {\n      helloWorld() {\n        return "Hello from my first GraphQL resolver!";\n      },\n    },\n  };\n\n  // using an array of middlewares to apply\n  const middlewares = [];\n\n  // any dependencies that might be required by the Resolver Map Middlewares or\n  // Resolver Wrappers. `graphqlSchema` is a required dependency;\n  const dependencies = {\n    graphqlSchema,\n  };\n\n  const packed = await pack(resolverMap, middlewares, {\n    dependencies,\n  });\n\n  // the packed result includes a `resolverMap` field that would have applied any\n  // middlewares. These can then be applied in place of where you would have used\n  // your previous resolverMap\n  const packedResolverMap = packed.resolverMap;\n\n  // `makeExecutableSchema` is how graphql-tools creates applies a Resolver Map\n  // to a Schema so that it can accept queries\n  const executableSchema = makeExecutableSchema({\n    typeDefs: printSchema(graphqlSchema),\n\n    // BEFORE using `graphql-mocks` this would have uses the original resolver map\n    // resolvers: resolverMap,\n\n    // AFTER, it uses the packed Resolver Map which includes the application of\n    // Resolver Map Middlewares and any Resolver Wrappers\n    resolvers: packedResolverMap,\n  });\n\n  const result = await graphql(\n    executableSchema,\n    `\n      query {\n        helloWorld\n      }\n    `\n  );\n\n  return result;\n}\n\n// kick everything off\nrun();\n')))}s.isMDXComponent=!0;var p=r(207),c=r(106),u=["components"],d={title:"Manually Apply Middlewares"},h={unversionedId:"guides/pack",id:"guides/pack",isDocsHomePage:!1,title:"Manually Apply Middlewares",description:"import",source:"@site/docs/guides/pack.mdx",slug:"/guides/pack",permalink:"/docs/guides/pack",version:"current",sidebar:"docs",previous:{title:"Mirage JS",permalink:"/docs/guides/mirage-js"}},m=[{value:"Using <code>pack</code> with an Existing GraphQL Handler",id:"using-pack-with-an-existing-graphql-handler",children:[]}],b={rightToc:m};function y(e){var n=e.components,r=Object(t.a)(e,u);return Object(i.b)("wrapper",Object(a.a)({},b,r,{components:n,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"pack")," function can be used to manually apply Resolver Map Middlewares to Resolver Maps. This is especially useful\nwith an existing GraphQL Handler is already setup with a Resolver Map."),Object(i.b)("h2",{id:"using-pack-with-an-existing-graphql-handler"},"Using ",Object(i.b)("inlineCode",{parentName:"h2"},"pack")," with an Existing GraphQL Handler"),Object(i.b)("p",null,"If you are getting started and haven't set up a GraphQL handler yet, it is easier to use the library's GraphQL handler\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../getting-started/create-handler"}),"create a GraphQL handler")," instead."),Object(i.b)("p",null,"Otherwise, if you already have a handler set up you most likely can still use it with this library if you have a\nResolver Map. This library provides a ",Object(i.b)("inlineCode",{parentName:"p"},"pack")," function which takes an initial Resolver Map and applies operations against\nit using Resolver Map Middlewares. The result of ",Object(i.b)("inlineCode",{parentName:"p"},"pack"),' is a new "packed" Resolver Map that can now be used in your\nexisting GraphQL handler.'),Object(i.b)("p",null,"Here is an example that uses the third-party package, ",Object(i.b)("inlineCode",{parentName:"p"},"graphql-tools"),", and its handler."),Object(i.b)(s,{mdxType:"ExistingHandlerExample"}),Object(i.b)(c.a,{result:p.a,mdxType:"GraphQLResult"}))}y.isMDXComponent=!0},91:function(e,n,r){"use strict";r.d(n,"a",(function(){return u})),r.d(n,"b",(function(){return m}));var a=r(0),t=r.n(a);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var p=t.a.createContext({}),c=function(e){var n=t.a.useContext(p),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},u=function(e){var n=c(e.components);return t.a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.a.createElement(t.a.Fragment,{},n)}},h=t.a.forwardRef((function(e,n){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),h=a,m=u["".concat(o,".").concat(h)]||u[h]||d[h]||i;return r?t.a.createElement(m,l(l({ref:n},p),{},{components:r})):t.a.createElement(m,l({ref:n},p))}));function m(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=r[p];return t.a.createElement.apply(null,o)}return t.a.createElement.apply(null,r)}h.displayName="MDXCreateElement"}}]);