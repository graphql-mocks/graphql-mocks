(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{102:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var b=o.a.createContext({}),p=function(e){var t=o.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=p(e.components);return o.a.createElement(b.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,b=l(e,["components","mdxType","originalType","parentName"]),s=p(n),m=a,d=s["".concat(c,".").concat(m)]||s[m]||u[m]||r;return n?o.a.createElement(d,i(i({ref:t},b),{},{components:n})):o.a.createElement(d,i({ref:t},b))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,c=new Array(r);c[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,c[1]=i;for(var b=2;b<r;b++)c[b]=n[b];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},84:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return b}));var a=n(2),o=(n(0),n(102));const r={id:"mutating-data",title:"Mutating Data"},c={unversionedId:"paper/mutating-data",id:"paper/mutating-data",isDocsHomePage:!1,title:"Mutating Data",description:"Data in the store is always mutated via the mutate method on a Paper instance by passing in a Mutation Transaction callback. Within the Mutation Transaction callback there are several operations available to support being able to make changes easily to the store, even custom ones can be added.",source:"@site/docs/paper/mutating-data.md",slug:"/paper/mutating-data",permalink:"/docs/paper/mutating-data",version:"current",sidebar:"docs",previous:{title:"Querying Data",permalink:"/docs/paper/querying-data"},next:{title:"Operations",permalink:"/docs/paper/operations"}},i=[{value:"<code>mutate</code> and the <em>Mutate Transaction</em> callback",id:"mutate-and-the-mutate-transaction-callback",children:[]},{value:"Transaction Operations",id:"transaction-operations",children:[{value:"<code>create</code>",id:"create",children:[]},{value:"<code>find</code>",id:"find",children:[]},{value:"<code>remove</code>",id:"remove",children:[]},{value:"<code>clone</code>",id:"clone",children:[]},{value:"<code>getStore</code>",id:"getstore",children:[]},{value:"<code>queueEvent</code>",id:"queueevent",children:[]}]},{value:"Creating Connections Between Documents",id:"creating-connections-between-documents",children:[{value:"Creating Connections via Document Properties",id:"creating-connections-via-document-properties",children:[]},{value:"Creating Connections within <code>create</code> via Nesting",id:"creating-connections-within-create-via-nesting",children:[]}]},{value:"Returning Data Outside the <em>Mutate Transaction</em> callback",id:"returning-data-outside-the-mutate-transaction-callback",children:[]}],l={rightToc:i};function b({components:e,...t}){return Object(o.b)("wrapper",Object(a.a)({},l,t,{components:e,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Data in the store is ",Object(o.b)("em",{parentName:"p"},"always")," mutated via the ",Object(o.b)("inlineCode",{parentName:"p"},"mutate")," method on a ",Object(o.b)("inlineCode",{parentName:"p"},"Paper")," instance by passing in a ",Object(o.b)("em",{parentName:"p"},"Mutation Transaction")," callback. Within the ",Object(o.b)("em",{parentName:"p"},"Mutation Transaction")," callback there are several operations available to support being able to make changes easily to the store, even custom ones can be added."),Object(o.b)("h2",{id:"mutate-and-the-mutate-transaction-callback"},Object(o.b)("inlineCode",{parentName:"h2"},"mutate")," and the ",Object(o.b)("em",{parentName:"h2"},"Mutate Transaction")," callback"),Object(o.b)("p",null,"To make any changes call the ",Object(o.b)("inlineCode",{parentName:"p"},"mutate")," method on the ",Object(o.b)("inlineCode",{parentName:"p"},"Paper")," instance and provide a ",Object(o.b)("em",{parentName:"p"},"Mutate Transaction")," callback."),Object(o.b)("p",null,"Operations can be destructured from the first argument provided in the ",Object(o.b)("em",{parentName:"p"},"Mutation Transaction")," callback. For example, an ",Object(o.b)("inlineCode",{parentName:"p"},"Actor")," document could be created within ",Object(o.b)("inlineCode",{parentName:"p"},"mutate")," by using the ",Object(o.b)("inlineCode",{parentName:"p"},"create")," operation. In this example only ",Object(o.b)("inlineCode",{parentName:"p"},"create")," is being destructured for use by any combination of operations can be used with the callback (see more out-of-the-box operations below)."),Object(o.b)("p",null,"For example, with a GraphQL Schema:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"schema {\n  query: Query\n}\n\ntype Query {\n  allFilms: [Film!]!\n}\n\ntype Film {\n  title: String!\n  actors: [Actor!]!\n}\n\ntype Actor {\n  name: String!\n}\n")),Object(o.b)("p",null,"The following ",Object(o.b)("em",{parentName:"p"},"Mutate Transaction")," callback will create a ",Object(o.b)("inlineCode",{parentName:"p"},"Document")," of the GraphQL ",Object(o.b)("inlineCode",{parentName:"p"},"Actor")," type."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create }) => {\n  create('Actor', {\n    name: 'Julia Roberts'\n  });\n});\n")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," ",Object(o.b)("inlineCode",{parentName:"p"},"mutate")," returns a promise and the transaction callback is not considered executed until the promise is fulfilled. Calls to ",Object(o.b)("inlineCode",{parentName:"p"},"mutate")," will process transaction callbacks in the order they are called."),Object(o.b)("p",null,"All changes within a ",Object(o.b)("em",{parentName:"p"},"Mutation Transaction")," callback will be validated via ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/paper/validations"}),"Validators")," after the transaction to ensure the new version of the ",Object(o.b)("inlineCode",{parentName:"p"},"DocumentStore")," is consistent."),Object(o.b)("h2",{id:"transaction-operations"},"Transaction Operations"),Object(o.b)("p",null,"Out of the box the following operations can be destructured within the callback:"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"create"),", ",Object(o.b)("inlineCode",{parentName:"p"},"find"),", ",Object(o.b)("inlineCode",{parentName:"p"},"remove"),", ",Object(o.b)("inlineCode",{parentName:"p"},"clone"),", ",Object(o.b)("inlineCode",{parentName:"p"},"getStore"),", ",Object(o.b)("inlineCode",{parentName:"p"},"queueEvent"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create, find, remove, clone, getStore, queueEvent }) => {\n  // do something within the callback\n});\n")),Object(o.b)("p",null,"Creating custom operations is supported and can be helpful for creating common functional mutations to the GraphQL store or to provide common helpers that are useful within a ",Object(o.b)("em",{parentName:"p"},"Transaction Callback"),"."),Object(o.b)("h3",{id:"create"},Object(o.b)("inlineCode",{parentName:"h3"},"create")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/api/paper/modules/operations.html#create"}),"API"))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create }) => {\n  const julia = create('Actor', {\n    name: 'Julia Roberts'\n  });\n});\n")),Object(o.b)("p",null,"The first argument is the GraphQL type for the document and the second is an object representing its fields."),Object(o.b)("h4",{id:"creating-a-documented-with-connections"},"Creating a Documented with Connections"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"create")," operation supports the ability to create connections through either by a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#creating-connections-within-create-via-nesting"}),"nested object")," or explicitly through the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#creating-connections-via-document-properties"}),"property on the document"),", both of which are covered below."),Object(o.b)("h3",{id:"find"},Object(o.b)("inlineCode",{parentName:"h3"},"find")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/api/paper/modules/operations.html#find"}),"API"))),Object(o.b)("p",null,"In order to make changes to documents it's important to have access to a version of the document that can be mutated. If there is access to a read-only/frozen/stale document in scope, a mutable version can be looked up via ",Object(o.b)("inlineCode",{parentName:"p"},"find"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"let existingDocument;\n\nawait paper.mutate(({ find }) => {\n  const mutatableVersion = find(existingDocument);\n});\n")),Object(o.b)("h3",{id:"remove"},Object(o.b)("inlineCode",{parentName:"h3"},"remove")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/api/paper/modules/operations.html#remove"}),"API"))),Object(o.b)("p",null,"To remove a ",Object(o.b)("inlineCode",{parentName:"p"},"Document")," from the store use the ",Object(o.b)("inlineCode",{parentName:"p"},"remove")," operation."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ remove }) => {\n  remove(document);\n});\n")),Object(o.b)("h3",{id:"clone"},Object(o.b)("inlineCode",{parentName:"h3"},"clone")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/api/paper/modules/operations.html#clone"}),"API"))),Object(o.b)("p",null,"Use the ",Object(o.b)("inlineCode",{parentName:"p"},"clone")," operation to create a new document that copies the properties and connections of an existing document."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ clone }) => {\n  const newDocument = clone(document);\n});\n")),Object(o.b)("h3",{id:"getstore"},Object(o.b)("inlineCode",{parentName:"h3"},"getStore")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/api/paper/modules/operations.html#getStore"}),"API"))),Object(o.b)("p",null,"This operation gives the ",Object(o.b)("em",{parentName:"p"},"current")," read ",Object(o.b)("strong",{parentName:"p"},"and write")," version of the store available for mutating within the ",Object(o.b)("em",{parentName:"p"},"Mutation Transaction")," callback. This is useful for when access to underlying ",Object(o.b)("inlineCode",{parentName:"p"},"DocumentStore")," data structure and its ",Object(o.b)("inlineCode",{parentName:"p"},"Documents")," is required. It can also be useful to query by using typical javascript methods, for example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ getStore }) => {\n  const store = getStore();\n  // Get the `Actor` document for \"Julia Roberts\" using available\n  // javascript array methods\n  const julia = store.Actor.find(({ name }) => name === 'Julia Roberts');\n});\n")),Object(o.b)("p",null,"If common modifications are being done via ",Object(o.b)("inlineCode",{parentName:"p"},"getStore")," consider making a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/paper/operations#creating-custom-operations"}),"custom operation"),"."),Object(o.b)("h3",{id:"queueevent"},Object(o.b)("inlineCode",{parentName:"h3"},"queueEvent")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"/api/paper/modules/operations.html#queueEvent"}),"API"))),Object(o.b)("p",null,"Use the ",Object(o.b)("inlineCode",{parentName:"p"},"queueEvent")," operation to queue an event to be dispatched after the transaction is complete. The ",Object(o.b)("inlineCode",{parentName:"p"},"queueEvent")," takes an instance of ",Object(o.b)("inlineCode",{parentName:"p"},"Event"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ queueEvent }) => {\n  queueEvent(new Event('meow', { /* custom event data */ }));\n});\n")),Object(o.b)("h2",{id:"creating-connections-between-documents"},"Creating Connections Between Documents"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"Connection")," is used to create a relationship between Documents where one GraphQL type references another GraphQL type in the GraphQL schema."),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"Document")," reference can: be:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"one-to-one, ie: one film can have one leading actor:")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"type Film {\n  leadingActor: Actor\n}\n")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"one-to-many, ie: one film can have many actors:")),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-graphql"}),"type Film {\n  leadingActors: [Actor]\n}\n")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," Non-null (denoted by a ",Object(o.b)("inlineCode",{parentName:"p"},"!"),", ie: ",Object(o.b)("inlineCode",{parentName:"p"},"Actor!"),", ",Object(o.b)("inlineCode",{parentName:"p"},"[Actor!]!"),", ",Object(o.b)("inlineCode",{parentName:"p"},"[Actor!]"),", ",Object(o.b)("inlineCode",{parentName:"p"},"[Actor]!"),") variations of these work also."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:"),' Connections are one direction. If "Document A" is connected to "Document B" and "Document B" is also connected to "Document A" then two connectiosn must be defined explicitly. There is no automatic reflexive assumptions or setup done (although a custom operation could be created to help handle this case).'),Object(o.b)("h3",{id:"creating-connections-via-document-properties"},"Creating Connections via Document Properties"),Object(o.b)("p",null,"Within a ",Object(o.b)("em",{parentName:"p"},"Mutate Transaction")," callback changes can be made to any documents and their properties."),Object(o.b)("h4",{id:"one-to-one-connections"},"One-to-One Connections"),Object(o.b)("p",null,"To create a one-way one-to-one connection between a parent document and its child assign the property to a Document reference (see ",Object(o.b)("inlineCode",{parentName:"p"},"leadingActor")," property assigned to the ",Object(o.b)("inlineCode",{parentName:"p"},"jeffGoldblum")," child document below)."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create }) => {\n  const jeffGoldblum = create('Actor', {\n    name: 'Jeff Goldblum'\n  });\n\n  // as a property within `create`\n  const jurassicPark = create('Film', {\n    name: 'Jurassic Park',\n    leadingActor: jeffGoldblum\n  });\n\n  // or assigned after\n  const lifeAquatic = create('Film', {\n    name: 'The Life Aquatic'\n  });\n  lifeAquatic.leadingActor = jeffGoldbum;\n});\n")),Object(o.b)("h4",{id:"one-to-many-connections"},"One-to-Many Connections"),Object(o.b)("p",null,"To create a one-way one-to-many connection reference documents on the property via an Array, either on an existing or new document."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create }) => {\n  const anjelicaHuston = create('Actor', {\n    name: 'Anjelica Huston'\n  });\n\n  const owenWilson = create('Actor', {\n    name: 'Owen Wilson'\n  });\n\n  // as a property within `create`\n  const theRoyalTenebaums = create('Film', {\n    title: 'The Royal Tenebaums',\n    actors: [anjelicaHuston, owenWilson]\n  })\n\n  // or assigned after via `push` to an array\n  const theLifeAquatic = create('Film', {\n    title: 'The Life Aquatic'\n  });\n\n  // This works assuming it's a non-null list:\n  // (ie: `actors: [Actor]!` or `actors: [Actor!]!`.\n  //\n  // Otherwise the array needs to be created first:\n  // `theLifeAquatic.actors = theLifeAquatic.actors ?? [];`\n  //\n  // see note below for more details\n  theLifeAquatic.actors.push(anjelicaHuston, owenWilson);\n});\n")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," While less typical in GraphQL Schemas, if a one-to-many property can nullable (ie: ",Object(o.b)("inlineCode",{parentName:"p"},"actors: [Actor]")," ",Object(o.b)("em",{parentName:"p"},"without")," an ",Object(o.b)("inlineCode",{parentName:"p"},"!")," outside the list) then it's important to make sure you are working with an array before pushing to it. The ",Object(o.b)("inlineCode",{parentName:"p"},"??")," can help in this case. If working with a non-null list (",Object(o.b)("inlineCode",{parentName:"p"},"[Actor]!")," or  ",Object(o.b)("inlineCode",{parentName:"p"},"[Actor!]!"),") then it will already be an array by default."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create }) => {\n  film.actors = film.actors ?? [];\n  film.actors.push(newActor);\n});\n")),Object(o.b)("h3",{id:"creating-connections-within-create-via-nesting"},"Creating Connections within ",Object(o.b)("inlineCode",{parentName:"h3"},"create")," via Nesting"),Object(o.b)("p",null,"One powerful technique is to use the ",Object(o.b)("inlineCode",{parentName:"p"},"create")," operation with a nested object that includes its connections. This nesting will work recursively. Other documents that have already been created can be included, too."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"await paper.mutate(({ create }) => {\n  // documents created outside of nesting can be used within nesting, too\n  const scarlettJohansson = create('Actor', { name: 'Scarlett Johansson' });\n\n  const isleOfDogs = create('Film', {\n    title: 'Isle of Dogs',\n    actors: [\n      scarlettJohansson,\n      { name: 'Jeff Goldblum' },\n      { name: 'Tilda Swinton' },\n      { name: 'Bill Murray' },\n      { name: 'Bryan Cranston' },\n    ]\n  });\n});\n")),Object(o.b)("p",null,"This nested ",Object(o.b)("inlineCode",{parentName:"p"},"create")," will end up creating a ",Object(o.b)("inlineCode",{parentName:"p"},"Film")," document and four ",Object(o.b)("inlineCode",{parentName:"p"},"Actor")," documents, skipping creating ",Object(o.b)("inlineCode",{parentName:"p"},"scarlettJohansson")," because the ",Object(o.b)("inlineCode",{parentName:"p"},"Actor")," document was already created but it will still be included as a connection."),Object(o.b)("h2",{id:"returning-data-outside-the-mutate-transaction-callback"},"Returning Data Outside the ",Object(o.b)("em",{parentName:"h2"},"Mutate Transaction")," callback"),Object(o.b)("p",null,"It's also very useful to stash documents that have been used or created within a ",Object(o.b)("inlineCode",{parentName:"p"},"mutate")," transaction afterwards. This can be done by returning a document, an array of documents, or an object with documents values, from the ",Object(o.b)("em",{parentName:"p"},"Mutate Transaction")," callback. See ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/paper/querying-data#returning-documents-from-mutation-transactions"}),Object(o.b)("em",{parentName:"a"},"Returning Documents from Mutation Transactions"))," for examples."))}b.isMDXComponent=!0}}]);