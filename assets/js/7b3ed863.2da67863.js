"use strict";(self.webpackChunk_graphql_mocks_docs=self.webpackChunk_graphql_mocks_docs||[]).push([[2657],{22966:function(e,t,r){r.r(t),r.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return c}});var a=r(28427),n=r(84397),o=(r(2784),r(30876)),l=["components"],i={id:"concepts",title:"Concepts"},s=void 0,p={unversionedId:"getting-started/concepts",id:"getting-started/concepts",title:"Concepts",description:"These are some concepts and terms you might see when looking to mock your GraphQL API.",source:"@site/docs/getting-started/concepts.md",sourceDirName:"getting-started",slug:"/getting-started/concepts",permalink:"/docs/getting-started/concepts",draft:!1,tags:[],version:"current",frontMatter:{id:"concepts",title:"Concepts"},sidebar:"docs",previous:{title:"Installation",permalink:"/docs/getting-started/installation"},next:{title:"Quick Example",permalink:"/docs/getting-started/quick-example"}},d={},c=[{value:"GraphQL Concepts",id:"graphql-concepts",level:2},{value:"Resolver",id:"resolver",level:3},{value:"Resolver Map",id:"resolver-map",level:3},{value:"Library Concepts",id:"library-concepts",level:2},{value:"Resolver Wrapper",id:"resolver-wrapper",level:3},{value:"Resolver Map Middleware",id:"resolver-map-middleware",level:3},{value:"Highlight",id:"highlight",level:2},{value:"GraphQL Handler",id:"graphql-handler",level:2},{value:"GraphQL Paper",id:"graphql-paper",level:2},{value:"A Note on Composability",id:"a-note-on-composability",level:2}],h={toc:c};function u(e){var t=e.components,r=(0,n.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"These are some concepts and terms you might see when looking to mock your GraphQL API."),(0,o.kt)("h2",{id:"graphql-concepts"},"GraphQL Concepts"),(0,o.kt)("p",null,"Since this library aims at mimicking a GraphQL API server it is focuses on the ",(0,o.kt)("em",{parentName:"p"},"execution")," and resolution of queries. We\nuse Resolvers and Resolver Maps to handle this execution. The ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/execution"},"graphql docs")," have\nsome useful information around these concepts. With a Resolver Map, and any optional Middlewares, a GraphQL Handler be\ncreated to resolve queries."),(0,o.kt)("h3",{id:"resolver"},"Resolver"),(0,o.kt)("p",null,"Resolvers are functions that are responsible for returning the data for a field on a type."),(0,o.kt)("p",null,"For the given schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"schema {\n  query: Query\n}\n\n# Query is the type\ntype Query {\n  # `helloWorld` is the field on the Query type that should\n  # resolve to a string\n  helloWorld: String!\n}\n")),(0,o.kt)("p",null,"A resolver function for the ",(0,o.kt)("inlineCode",{parentName:"p"},"helloWorld")," field could be:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolverFunction = function (obj, args, context, info) {\n  return 'Hello world, from a GraphQL Resolver!';\n};\n")),(0,o.kt)("p",null,"This resolver function on its own isn't very useful, we need to attach it to a field on a Resolver Map. To learn more\nabout resolvers themselves check out this part of the\n",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/execution/#root-fields-resolvers"},"graphql documentation"),"."),(0,o.kt)("p",null,"Note: Usually, Resolvers refer to Field Resolvers (which resolve data for a field), however, there are also Type\nResolvers which instead resolve to a concrete ",(0,o.kt)("em",{parentName:"p"},"Type")," for Abstract Types like\n",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/schema/#interfaces"},"Interfaces")," and ",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/learn/schema/#union-types"},"Unions"),".\nThis is covered more in the Resolver section of these guides."),(0,o.kt)("h3",{id:"resolver-map"},"Resolver Map"),(0,o.kt)("p",null,"Resolver Maps are a collection of resolvers keyed by type and field. Here's the same schema and resolver function from\nabove being used within a Resolver Map."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"# Query is the type\ntype Query {\n  helloWorld: String!\n}\n")),(0,o.kt)("p",null,"A Resolver Map for this schema could look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const resolverMap = {\n  // Query is the first property representing the Query type\n  Query: {\n    // the `helloWorld` property on Query represents the field\n    // on Query, and attached to it is our resolverFunction form above\n    helloWorld: resolverFunction,\n  },\n};\n")),(0,o.kt)("p",null,"With a Resolver Map the types, fields, and resolvers are enough to completely resolve queries. This library provides\ntools to setup, extend, and organize both Resolver Maps and Resolvers."),(0,o.kt)("h2",{id:"library-concepts"},"Library Concepts"),(0,o.kt)("p",null,"This library provides functionality to extend resolvers and make modifications to Resolver Maps."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"GraphQL Concept"),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"th"},"graphql-mocks")," Concept"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Resolver"),(0,o.kt)("td",{parentName:"tr",align:null},"Resolver Wrapper")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Resolver Map"),(0,o.kt)("td",{parentName:"tr",align:null},"Resolver Map Middleware")))),(0,o.kt)("h3",{id:"resolver-wrapper"},"Resolver Wrapper"),(0,o.kt)("p",null,"Resolver Wrappers provide a functional way of extending and wrapping a Resolver function. Wrappers are given a Resolver\nand are responsible for returning a Resolver. They provide a good way of introspecting and controlling the result of a\nResolver and can be applied to Resolvers flexibly using utilities like ",(0,o.kt)("inlineCode",{parentName:"p"},"embed")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"layer"),"."),(0,o.kt)("p",null,"Learn more about different types of ",(0,o.kt)("a",{parentName:"p",href:"/docs/resolver/using-resolvers"},"Resolvers")," and about ",(0,o.kt)("a",{parentName:"p",href:"/docs/resolver/introducing-wrappers"},"Resolver Wrappers"),"."),(0,o.kt)("h3",{id:"resolver-map-middleware"},"Resolver Map Middleware"),(0,o.kt)("p",null,"Resolver Map Middlewares apply transformations to a Resolver Map. A Middleware function is responsible for taking in a\nResolver Map and returning a, potentially modified, Resolver Map. You can save these Middlewares to re-use, mix and\nmatch, and combine them for different scenarios. This is handy because for the number of mock scenarios that must be handled it's important to have declarative control over the Resolver landscape."),(0,o.kt)("p",null,"Learn more about ",(0,o.kt)("a",{parentName:"p",href:"/docs/resolver-map/using-resolver-maps"},"Resolver Maps")," and ",(0,o.kt)("a",{parentName:"p",href:"/docs/resolver-map/introducing-middlewares"},"Resolver Map Middlewares"),"."),(0,o.kt)("h2",{id:"highlight"},"Highlight"),(0,o.kt)("p",null,"The ability to select the parts of the schema to operate on, and mock, is made easier by using the declarative Highlight\nsystem. You will most likely encounter Highlight when interacting with Resolver Map Middlewares to apply modifications\nto specific parts of the GraphQL Schema. This allows middlewares to work in tandem without over each other."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Using the ",(0,o.kt)("inlineCode",{parentName:"em"},"field")," highlighter highlight all fields, on all types, excluding the ",(0,o.kt)("inlineCode",{parentName:"em"},"Mutation.addUser"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"highlight(graphqlSchema)\n  .include(field([HIGHLIGHT_ALL, HIGHLIGHT_ALL]))\n  .exclude(field(['Mutation', 'addUser']));\n")),(0,o.kt)("p",null,"Learn the ",(0,o.kt)("a",{parentName:"p",href:"/docs/highlight/introducing-highlight"},"basics of Highlight"),", the ones that are\n",(0,o.kt)("a",{parentName:"p",href:"/docs/highlight/available-highlighters"},"provided out-of-the-box"),", and how to\n",(0,o.kt)("a",{parentName:"p",href:"/docs/highlight/creating-highlighters"},"create your own"),"."),(0,o.kt)("h2",{id:"graphql-handler"},"GraphQL Handler"),(0,o.kt)("p",null,"This library aims at making it easy to get setup and firing off queries by including\n",(0,o.kt)("a",{parentName:"p",href:"/docs/handler/introducing-handler"},"a GraphQL Handler"),". A GraphQL Handler will take a query and variables, and apply\nit against a GraphQL Schema and its Resolver Map."),(0,o.kt)("p",null,"Already have a GraphQL Handler setup, maybe from using ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql-tools"),"? You can still use ",(0,o.kt)("inlineCode",{parentName:"p"},"pack")," to create a Resolver\nMap that includes the Middlewares and Wrappers and everything necessary to pass to your existing setup."),(0,o.kt)("h2",{id:"graphql-paper"},"GraphQL Paper"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/paper/introducing-paper"},"GraphQL Paper")," is a library provided by ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql-mocks")," but can be used standalone. It it an in-memory store for stateful handling of data based on a GraphQL Schema. It's been designed and tested to integrate with ",(0,o.kt)("inlineCode",{parentName:"p"},"graphql-mocks")," to provide a complete GraphQL mocking story."),(0,o.kt)("h2",{id:"a-note-on-composability"},"A Note on Composability"),(0,o.kt)("p",null,"Both Resolver Map Middlewares and Resolver Wrappers are based around functional composition so that they can be applied\nflexibly. This flexibility is often powered by the ",(0,o.kt)("em",{parentName:"p"},"Highlight")," system to selectively apply the operation to specific\nparts of the schema. Flexibility is considered important here because it empowers the creation of specific mock and test\nGraphQL APIs scenarios. This is done in a way that is easier and clearer than managing Resolvers and Resolver Maps by\nhand or leaving everything up to a rigidly automatic solution (which can also be codified with this libraries\nprimitives). GraphQL Paper provides a stateful in-memory store for representing data backed by a GraphQL Schema that can be easily modified from mutations. The GraphQL Paper store can also be customized and extended with events, hooks, and custom validations."))}u.isMDXComponent=!0},30876:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return u}});var a=r(2784);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),p=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),h=p(r),u=n,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||o;return r?a.createElement(m,l(l({ref:t},d),{},{components:r})):a.createElement(m,l({ref:t},d))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,l=new Array(o);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,l[1]=i;for(var p=2;p<o;p++)l[p]=r[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"}}]);