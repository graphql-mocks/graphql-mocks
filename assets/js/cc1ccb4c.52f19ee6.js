"use strict";(self.webpackChunk_graphql_mocks_docs=self.webpackChunk_graphql_mocks_docs||[]).push([[1554],{83133:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(28427),o=n(84397),r=(n(2784),n(30876)),i=["components"],l={id:"mutating-data",title:"Mutating Data"},c=void 0,p={unversionedId:"paper/mutating-data",id:"paper/mutating-data",title:"Mutating Data",description:"Data in the store is always mutated via the mutate method on a Paper instance by passing in a Mutation Transaction callback. Within the Mutation Transaction callback there are several operations available to support being able to make changes easily to the store, even custom ones can be added.",source:"@site/docs/paper/mutating-data.md",sourceDirName:"paper",slug:"/paper/mutating-data",permalink:"/docs/paper/mutating-data",draft:!1,tags:[],version:"current",frontMatter:{id:"mutating-data",title:"Mutating Data"},sidebar:"docs",previous:{title:"Querying Data",permalink:"/docs/paper/querying-data"},next:{title:"Operations",permalink:"/docs/paper/operations"}},s={},u=[{value:"<code>mutate</code> and the <em>Mutate Transaction</em> callback",id:"mutate-and-the-mutate-transaction-callback",level:2},{value:"Transaction Operations",id:"transaction-operations",level:2},{value:"<code>create</code>",id:"create",level:3},{value:"Creating a Documented with Connections",id:"creating-a-documented-with-connections",level:4},{value:"<code>find</code>",id:"find",level:3},{value:"<code>remove</code>",id:"remove",level:3},{value:"<code>clone</code>",id:"clone",level:3},{value:"<code>getStore</code>",id:"getstore",level:3},{value:"<code>queueEvent</code>",id:"queueevent",level:3},{value:"Creating Connections Between Documents",id:"creating-connections-between-documents",level:2},{value:"Creating Connections via Document Properties",id:"creating-connections-via-document-properties",level:3},{value:"One-to-One Connections",id:"one-to-one-connections",level:4},{value:"One-to-Many Connections",id:"one-to-many-connections",level:4},{value:"Creating Connections within <code>create</code> via Nesting",id:"creating-connections-within-create-via-nesting",level:3},{value:"Returning Data Outside the <em>Mutate Transaction</em> callback",id:"returning-data-outside-the-mutate-transaction-callback",level:2}],m={toc:u};function d(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Data in the store is ",(0,r.kt)("em",{parentName:"p"},"always")," mutated via the ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," method on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Paper")," instance by passing in a ",(0,r.kt)("em",{parentName:"p"},"Mutation Transaction")," callback. Within the ",(0,r.kt)("em",{parentName:"p"},"Mutation Transaction")," callback there are several operations available to support being able to make changes easily to the store, even ",(0,r.kt)("a",{parentName:"p",href:"/docs/paper/operations#creating-custom-operations"},"custom ones can be added"),"."),(0,r.kt)("h2",{id:"mutate-and-the-mutate-transaction-callback"},(0,r.kt)("inlineCode",{parentName:"h2"},"mutate")," and the ",(0,r.kt)("em",{parentName:"h2"},"Mutate Transaction")," callback"),(0,r.kt)("p",null,"To make any changes call the ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," method on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Paper")," instance and provide a ",(0,r.kt)("em",{parentName:"p"},"Mutate Transaction")," callback."),(0,r.kt)("p",null,"Operations can be destructured from the first argument provided in the ",(0,r.kt)("em",{parentName:"p"},"Mutation Transaction")," callback."),(0,r.kt)("p",null,"For example, an ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," document could be created within ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," by using the ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," operation. In this example only ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," is being destructured for use but any combination of operations can be used with the callback (see more of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/paper/mutating-data#transaction-operations"},"library-provided operations")," below)."),(0,r.kt)("p",null,"With a GraphQL Schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"schema {\n  query: Query\n}\n\ntype Query {\n  allFilms: [Film!]!\n}\n\ntype Film {\n  title: String!\n  actors: [Actor!]!\n}\n\ntype Actor {\n  name: String!\n}\n")),(0,r.kt)("p",null,"The following ",(0,r.kt)("em",{parentName:"p"},"Mutate Transaction")," callback will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," of the GraphQL ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create }) => {\n  create('Actor', {\n    name: 'Julia Roberts'\n  });\n});\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," returns a promise and the transaction callback is not considered executed until the promise is fulfilled. Calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," will process transaction callbacks in the order they are called."),(0,r.kt)("p",null,"All changes within a ",(0,r.kt)("em",{parentName:"p"},"Mutation Transaction")," callback will be validated via ",(0,r.kt)("a",{parentName:"p",href:"/docs/paper/validations"},"Validators")," after the transaction to ensure the new version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"DocumentStore")," is consistent."),(0,r.kt)("h2",{id:"transaction-operations"},"Transaction Operations"),(0,r.kt)("p",null,"Out of the box the following operations can be destructured within the callback:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"create"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"find"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"remove"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"clone"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"getStore"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"queueEvent"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create, find, remove, clone, getStore, queueEvent }) => {\n  // do something within the callback\n});\n")),(0,r.kt)("p",null,"Creating ",(0,r.kt)("a",{parentName:"p",href:"/docs/paper/operations#creating-custom-operations"},"custom operations")," can be helpful for creating common functional mutations on the GraphQL Paper ",(0,r.kt)("inlineCode",{parentName:"p"},"DocumentStore")," or to provide common helpers that are useful within a ",(0,r.kt)("em",{parentName:"p"},"Transaction Callback"),"."),(0,r.kt)("h3",{id:"create"},(0,r.kt)("inlineCode",{parentName:"h3"},"create")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"pathname:///api/paper/modules/operations.html#create"},"API"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create }) => {\n  const julia = create('Actor', {\n    name: 'Julia Roberts'\n  });\n});\n")),(0,r.kt)("p",null,"The first argument is the GraphQL type for the document and the second is an object representing its data, mapping GraphQL fields to the object properties."),(0,r.kt)("h4",{id:"creating-a-documented-with-connections"},"Creating a Documented with Connections"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," operation supports the ability to create connections through either by a ",(0,r.kt)("a",{parentName:"p",href:"#creating-connections-within-create-via-nesting"},"nested object")," or explicitly through the ",(0,r.kt)("a",{parentName:"p",href:"#creating-connections-via-document-properties"},"property on the document"),", both of which are covered below."),(0,r.kt)("h3",{id:"find"},(0,r.kt)("inlineCode",{parentName:"h3"},"find")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"pathname:///api/paper/modules/operations.html#find"},"API"))),(0,r.kt)("p",null,"In order to make changes to documents it's important to have access to a version of the document that can be mutated. If there is access to a read-only/frozen/stale document in scope, a mutable version can be looked up via ",(0,r.kt)("inlineCode",{parentName:"p"},"find"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let existingDocument;\n\nawait paper.mutate(({ find }) => {\n  const mutableVersion = find(existingDocument);\n});\n")),(0,r.kt)("h3",{id:"remove"},(0,r.kt)("inlineCode",{parentName:"h3"},"remove")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"pathname:///api/paper/modules/operations.html#remove"},"API"))),(0,r.kt)("p",null,"To remove a ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," from the store use the ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," operation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ remove }) => {\n  remove(document);\n});\n")),(0,r.kt)("h3",{id:"clone"},(0,r.kt)("inlineCode",{parentName:"h3"},"clone")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"pathname:///api/paper/modules/operations.html#clone"},"API"))),(0,r.kt)("p",null,"Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"clone")," operation to create a new document that copies the properties and connections of an existing document."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ clone }) => {\n  const newDocument = clone(document);\n});\n")),(0,r.kt)("h3",{id:"getstore"},(0,r.kt)("inlineCode",{parentName:"h3"},"getStore")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"pathname:///api/paper/modules/operations.html#getStore"},"API"))),(0,r.kt)("p",null,"This operation gives the current ",(0,r.kt)("strong",{parentName:"p"},"mutable")," version of the ",(0,r.kt)("inlineCode",{parentName:"p"},"DocumentStore")," available for mutating within the ",(0,r.kt)("em",{parentName:"p"},"Mutation Transaction")," callback. This is useful for when access to underlying ",(0,r.kt)("inlineCode",{parentName:"p"},"DocumentStore")," data structure and its ",(0,r.kt)("inlineCode",{parentName:"p"},"Documents")," is required. It can also be useful to query by using typical javascript methods, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ getStore }) => {\n  const store = getStore();\n  // Get the `Actor` document for \"Julia Roberts\" using available\n  // javascript array methods\n  const julia = store.Actor.find(({ name }) => name === 'Julia Roberts');\n});\n")),(0,r.kt)("p",null,"If common modifications are being done via ",(0,r.kt)("inlineCode",{parentName:"p"},"getStore")," consider making a ",(0,r.kt)("a",{parentName:"p",href:"/docs/paper/operations#creating-custom-operations"},"custom operation"),"."),(0,r.kt)("h3",{id:"queueevent"},(0,r.kt)("inlineCode",{parentName:"h3"},"queueEvent")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"pathname:///api/paper/modules/operations.html#queueEvent"},"API"))),(0,r.kt)("p",null,"Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"queueEvent")," operation to queue an event to be dispatched after the transaction is complete. The ",(0,r.kt)("inlineCode",{parentName:"p"},"queueEvent")," takes an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Event"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ queueEvent }) => {\n  queueEvent(new Event('meow', { /* custom event data */ }));\n});\n")),(0,r.kt)("h2",{id:"creating-connections-between-documents"},"Creating Connections Between Documents"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"Connection")," is used to create a relationship between Documents where one GraphQL type references another GraphQL type in the GraphQL schema."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Document")," reference can be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"one-to-one, ie: one film can have one leading actor:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Film {\n  leadingActor: Actor\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"one-to-many, ie: one film can have many actors:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Film {\n  leadingActors: [Actor]\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," Non-null (denoted by a ",(0,r.kt)("inlineCode",{parentName:"p"},"!"),", ie: ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor!"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[Actor!]!"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[Actor!]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[Actor]!"),") variations of these also work and are validated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:"),' Connections are one direction. If "Document A" is connected to "Document B" and "Document B" is also connected to "Document A" then two connections must be defined explicitly. There is no automatic reflexive assumptions or setup done between connections (although a custom operation could be created to handle these cases).'),(0,r.kt)("h3",{id:"creating-connections-via-document-properties"},"Creating Connections via Document Properties"),(0,r.kt)("p",null,"Within a ",(0,r.kt)("em",{parentName:"p"},"Mutate Transaction")," callback changes can be made to any documents and their properties."),(0,r.kt)("h4",{id:"one-to-one-connections"},"One-to-One Connections"),(0,r.kt)("p",null,"To create a one-way one-to-one connection between a document and another, assign the property to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Document"),", see below where the ",(0,r.kt)("inlineCode",{parentName:"p"},"leadingActor")," property is connected by assigning the ",(0,r.kt)("inlineCode",{parentName:"p"},"jeffGoldblum")," document."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create }) => {\n  const jeffGoldblum = create('Actor', {\n    name: 'Jeff Goldblum'\n  });\n\n  // as a property within `create`\n  const jurassicPark = create('Film', {\n    name: 'Jurassic Park',\n    leadingActor: jeffGoldblum\n  });\n\n  // or assigned after\n  const lifeAquatic = create('Film', {\n    name: 'The Life Aquatic'\n  });\n\n  lifeAquatic.leadingActor = jeffGoldbum;\n});\n")),(0,r.kt)("h4",{id:"one-to-many-connections"},"One-to-Many Connections"),(0,r.kt)("p",null,"To create a one-way one-to-many connection reference documents on the property via an Array, this works with new and existing documents."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create }) => {\n  const anjelicaHuston = create('Actor', {\n    name: 'Anjelica Huston'\n  });\n\n  const owenWilson = create('Actor', {\n    name: 'Owen Wilson'\n  });\n\n  // on the `actors` property within `create`\n  const theRoyalTenebaums = create('Film', {\n    title: 'The Royal Tenebaums',\n    actors: [anjelicaHuston, owenWilson]\n  })\n\n  // or assigned after via `push` to an array\n  const theLifeAquatic = create('Film', {\n    title: 'The Life Aquatic'\n  });\n\n  // This works assuming it's a non-null list:\n  // (ie: `actors: [Actor]!` or `actors: [Actor!]!`.\n  //\n  // Otherwise the array needs to be created first since it could be null:\n  // `theLifeAquatic.actors = theLifeAquatic.actors ?? [];`\n  //\n  // see note below for more details\n  theLifeAquatic.actors.push(anjelicaHuston, owenWilson);\n});\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," While less typical in GraphQL Schemas, if a one-to-many property can nullable (ie: ",(0,r.kt)("inlineCode",{parentName:"p"},"actors: [Actor]")," ",(0,r.kt)("em",{parentName:"p"},"without")," an ",(0,r.kt)("inlineCode",{parentName:"p"},"!")," outside the list) then it's important to make sure you are working with an array before pushing to it. The ",(0,r.kt)("inlineCode",{parentName:"p"},"??")," can help in this case. If working with a non-null list (",(0,r.kt)("inlineCode",{parentName:"p"},"[Actor]!")," or  ",(0,r.kt)("inlineCode",{parentName:"p"},"[Actor!]!"),") then it will already be an array by default."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create }) => {\n  film.actors = film.actors ?? [];\n  film.actors.push(newActor);\n});\n")),(0,r.kt)("h3",{id:"creating-connections-within-create-via-nesting"},"Creating Connections within ",(0,r.kt)("inlineCode",{parentName:"h3"},"create")," via Nesting"),(0,r.kt)("p",null,"One powerful technique is to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," operation with a nested object that includes its connections. This nesting will work recursively. Other documents that have already been created can be included, too."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"await paper.mutate(({ create }) => {\n  // documents created outside of nesting can be used within nesting, too\n  const scarlettJohansson = create('Actor', { name: 'Scarlett Johansson' });\n\n  const isleOfDogs = create('Film', {\n    title: 'Isle of Dogs',\n    actors: [\n      scarlettJohansson,\n      { name: 'Jeff Goldblum' },\n      { name: 'Tilda Swinton' },\n      { name: 'Bill Murray' },\n      { name: 'Bryan Cranston' },\n    ]\n  });\n});\n")),(0,r.kt)("p",null,"This nested ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," will end up creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"Film")," document and four ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," documents, skipping creating ",(0,r.kt)("inlineCode",{parentName:"p"},"scarlettJohansson")," because the ",(0,r.kt)("inlineCode",{parentName:"p"},"Actor")," document was already created but it will still be included as a connection."),(0,r.kt)("h2",{id:"returning-data-outside-the-mutate-transaction-callback"},"Returning Data Outside the ",(0,r.kt)("em",{parentName:"h2"},"Mutate Transaction")," callback"),(0,r.kt)("p",null,"It's also very useful to return documents that have been used or created within a ",(0,r.kt)("inlineCode",{parentName:"p"},"mutate")," transaction to be referenced afterwards. This can be done by returning a document, an array of documents, or an object with documents values, from the ",(0,r.kt)("em",{parentName:"p"},"Mutate Transaction")," callback. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/paper/querying-data#returning-documents-from-mutation-transactions"},(0,r.kt)("em",{parentName:"a"},"Returning Documents from Mutation Transactions"))," for examples."))}d.isMDXComponent=!0},30876:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return d}});var a=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=o,h=m["".concat(c,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(h,i(i({ref:t},s),{},{components:n})):a.createElement(h,i({ref:t},s))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);