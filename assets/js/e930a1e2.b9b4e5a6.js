"use strict";(self.webpackChunk_graphql_mocks_docs=self.webpackChunk_graphql_mocks_docs||[]).push([[6337],{31366:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var a=t(28427),r=t(84397),o=(t(2784),t(30876)),i=["components"],s={id:"managing-ids",title:"Managing IDs"},u=void 0,c={unversionedId:"paper/guides/managing-ids",id:"paper/guides/managing-ids",title:"Managing IDs",description:"IDs that exist as scalars on a GraphQL Schema are considered part of the data of a Document. GraphQL Paper doesn't use them for tracking uniqueness although it does have ways of helping ensure that data for ID fields are kept unique and also help in generating ID values.",source:"@site/docs/paper/guides/managing-ids.md",sourceDirName:"paper/guides",slug:"/paper/guides/managing-ids",permalink:"/docs/paper/guides/managing-ids",draft:!1,tags:[],version:"current",frontMatter:{id:"managing-ids",title:"Managing IDs"},sidebar:"docs",previous:{title:"Using GraphQL Paper with GraphQL",permalink:"/docs/paper/guides/with-graphql"},next:{title:"Introducing the gqlmocks CLI",permalink:"/docs/cli/introducing-gqlmocks"}},p={},d=[{value:"Automatically Generating IDs",id:"automatically-generating-ids",level:2},{value:"Using a Custom Hook",id:"using-a-custom-hook",level:3},{value:"Using auto-incrementing IDs",id:"using-auto-incrementing-ids",level:4},{value:"Using UUIDs",id:"using-uuids",level:4},{value:"Using a Custom Operation",id:"using-a-custom-operation",level:3},{value:"Validating Unique IDs",id:"validating-unique-ids",level:2}],l={toc:d};function m(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"IDs that exist as scalars on a GraphQL Schema are considered part of the data of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Document"),". GraphQL Paper doesn't use them for tracking uniqueness although it does have ways of helping ensure that data for ID fields are kept unique and also help in generating ID values."),(0,o.kt)("h2",{id:"automatically-generating-ids"},"Automatically Generating IDs"),(0,o.kt)("p",null,"It can be helpful to have an automatically generated ID that reflects the ID format used by the GraphQL API being mocked."),(0,o.kt)("h3",{id:"using-a-custom-hook"},"Using a Custom Hook"),(0,o.kt)("p",null,"This can be done by using an ",(0,o.kt)("inlineCode",{parentName:"p"},"afterTransaction")," hook function to ensure that any IDs that are missing are added automatically. ",(0,o.kt)("a",{parentName:"p",href:"/docs/paper/hooks"},"Learn more about creating custom hooks"),"."),(0,o.kt)("p",null,"Assuming the GraphQL Paper document has an id field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-graphql"},"type SomeType {\n  id: ID!\n}\n")),(0,o.kt)("h4",{id:"using-auto-incrementing-ids"},"Using auto-incrementing IDs"),(0,o.kt)("p",null,"For most testing and development cases this should run fast enough, and only after each transaction. In the case this is too slow a custom operation could be created (see below)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function autoIncrementIdHook({ getStore }) {\n  const store = getStore();\n  Object.entries(store).forEach(([type, documents]) => {\n    // find the current maximum id for the current type\n    let maxId = documents.reduce((previous, document) => {\n      return Math.max(previous, Number(document.id));\n    }, 0);\n\n    // loop over each document that's missing an ID and\n    // add an incremented id\n    documents.forEach((document) => {\n      if (typeof document !== 'string') {\n        document.id = String(++maxId);\n      }\n    });\n  });\n}\n\npaper.hooks.afterTransaction.push(autoIncrementIdHook);\n")),(0,o.kt)("h4",{id:"using-uuids"},"Using UUIDs"),(0,o.kt)("p",null,"Using a custom ",(0,o.kt)("inlineCode",{parentName:"p"},"uuid")," function is simpler to generate a missing ID for any document missing one after a transaction is complete."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function addUuidHook({ getStore }) {\n  const store = getStore();\n  Object.entries(store).forEach(([type, documents]) => {\n    documents.forEach((document) => {\n      if (typeof document !== 'string') {\n        // using a uuid function from an npm package\n        document.id = uuid();\n      }\n    });\n  });\n};\n\npaper.hooks.afterTransaction.push(addUuidHook);\n")),(0,o.kt)("h3",{id:"using-a-custom-operation"},"Using a Custom Operation"),(0,o.kt)("p",null,"Another solution is to create a custom operation that wraps the provided ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," operation and keeps tracks of IDs. ",(0,o.kt)("a",{parentName:"p",href:"/docs/paper/operations#creating-custom-operations"},"Learn more about creating custom operations"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { create } from 'graphql-paper/operations';\n\n// track ids { [typename: string] : number }\nconst ids = {};\n\nconst customCreate = (context, typename, documentPartial) => {\n  const document = create(context, typename, documentPartial);\n\n  // increment or initialize\n  ids[typename] = (ids[typename] ?? 0) + 1;\n\n  // set incremented id\n  document.id = String(ids[typename]);\n\n  return document;\n};\n\nconst paper = new Paper(graphqlSchema, { operations: { customCreate } });\n")),(0,o.kt)("h2",{id:"validating-unique-ids"},"Validating Unique IDs"),(0,o.kt)("p",null,"By default GraphQL Paper is checking for unique IDs on a per-type basis with the ",(0,o.kt)("a",{parentName:"p",href:"/docs/paper/validations#uniqueidfieldvalidator"},(0,o.kt)("inlineCode",{parentName:"a"},"uniqueIdFieldValidator")),". If the ID constraint is more complicated than per type then it's recommended to create a custom field validator. ",(0,o.kt)("a",{parentName:"p",href:"/docs/paper/validations#creating-custom-field-validators"},"Learn more about creating custom field validators"),"."))}m.isMDXComponent=!0},30876:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=a.createContext({}),c=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(u.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},l=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),l=c(t),m=r,g=l["".concat(u,".").concat(m)]||l[m]||d[m]||o;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=l;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}l.displayName="MDXCreateElement"}}]);