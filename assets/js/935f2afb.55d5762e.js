"use strict";(self.webpackChunk_graphql_mocks_docs=self.webpackChunk_graphql_mocks_docs||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Getting Started","items":[{"type":"link","label":"Introduction","href":"/docs/getting-started/introduction","docId":"getting-started/introduction"},{"type":"link","label":"Installation","href":"/docs/getting-started/installation","docId":"getting-started/installation"},{"type":"link","label":"Concepts","href":"/docs/getting-started/concepts","docId":"getting-started/concepts"},{"type":"link","label":"Quick Example","href":"/docs/getting-started/quick-example","docId":"getting-started/quick-example"}],"collapsed":true,"collapsible":true},{"type":"category","label":"GraphQL Handler","items":[{"type":"link","label":"Introducing the GraphQL Handler","href":"/docs/handler/introducing-handler","docId":"handler/introducing-handler"},{"type":"link","label":"Using Middlewares","href":"/docs/handler/using-middlewares","docId":"handler/using-middlewares"},{"type":"link","label":"Handler State","href":"/docs/handler/handler-state","docId":"handler/handler-state"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Resolver & Wrappers ","items":[{"type":"link","label":"Using Resolvers","href":"/docs/resolver/using-resolvers","docId":"resolver/using-resolvers"},{"type":"link","label":"Introducing Resolver Wrappers","href":"/docs/resolver/introducing-wrappers","docId":"resolver/introducing-wrappers"},{"type":"link","label":"Applying Wrappers","href":"/docs/resolver/applying-wrappers","docId":"resolver/applying-wrappers"},{"type":"link","label":"Available Wrappers","href":"/docs/resolver/available-wrappers","docId":"resolver/available-wrappers"},{"type":"link","label":"Creating Custom Wrappers","href":"/docs/resolver/creating-wrappers","docId":"resolver/creating-wrappers"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Resolver Map & Middlewares","items":[{"type":"link","label":"Using Resolver Maps","href":"/docs/resolver-map/using-resolver-maps","docId":"resolver-map/using-resolver-maps"},{"type":"link","label":"Introducing Resolver Map Middlewares","href":"/docs/resolver-map/introducing-middlewares","docId":"resolver-map/introducing-middlewares"},{"type":"link","label":"Managing Resolvers with Middlewares","href":"/docs/resolver-map/managing-resolvers","docId":"resolver-map/managing-resolvers"},{"type":"link","label":"Available Middlewares","href":"/docs/resolver-map/available-middlewares","docId":"resolver-map/available-middlewares"},{"type":"link","label":"Creating Custom Middlewares","href":"/docs/resolver-map/creating-middlewares","docId":"resolver-map/creating-middlewares"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Network Handling","items":[{"type":"link","label":"Introducing Network Handlers","href":"/docs/network/introducing-network-handlers","docId":"network/introducing-network-handlers"},{"type":"link","label":"Mock Service Worker","href":"/docs/network/msw","docId":"network/msw"},{"type":"link","label":"Pretender","href":"/docs/network/pretender","docId":"network/pretender"},{"type":"link","label":"Express","href":"/docs/network/express","docId":"network/express"},{"type":"link","label":"Cypress","href":"/docs/network/cypress","docId":"network/cypress"},{"type":"link","label":"Nock","href":"/docs/network/nock","docId":"network/nock"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Highlight","items":[{"type":"link","label":"Introducing Highlight","href":"/docs/highlight/introducing-highlight","docId":"highlight/introducing-highlight"},{"type":"link","label":"Available Highlighters","href":"/docs/highlight/available-highlighters","docId":"highlight/available-highlighters"},{"type":"link","label":"Create Custom Highlighters","href":"/docs/highlight/creating-highlighters","docId":"highlight/creating-highlighters"}],"collapsed":true,"collapsible":true},{"type":"category","label":"GraphQL Paper","items":[{"type":"link","label":"Introducing GraphQL Paper","href":"/docs/paper/introducing-paper","docId":"paper/introducing-paper"},{"type":"link","label":"Installation","href":"/docs/paper/installation","docId":"paper/installation"},{"type":"link","label":"Querying Data","href":"/docs/paper/querying-data","docId":"paper/querying-data"},{"type":"link","label":"Mutating Data","href":"/docs/paper/mutating-data","docId":"paper/mutating-data"},{"type":"link","label":"Operations","href":"/docs/paper/operations","docId":"paper/operations"},{"type":"link","label":"Events","href":"/docs/paper/events","docId":"paper/events"},{"type":"link","label":"Hooks","href":"/docs/paper/hooks","docId":"paper/hooks"},{"type":"link","label":"Validations","href":"/docs/paper/validations","docId":"paper/validations"},{"type":"link","label":"Technical Notes","href":"/docs/paper/technical-notes","docId":"paper/technical-notes"},{"type":"category","label":"GraphQL Paper Guides","items":[{"type":"link","label":"Generating Data with Factories","href":"/docs/paper/guides/factories","docId":"paper/guides/factories"},{"type":"link","label":"Using GraphQL Paper with GraphQL","href":"/docs/paper/guides/with-graphql","docId":"paper/guides/with-graphql"},{"type":"link","label":"Managing IDs","href":"/docs/paper/guides/managing-ids","docId":"paper/guides/managing-ids"}],"collapsed":true,"collapsible":true}],"collapsed":true,"collapsible":true},{"type":"category","label":"CLI (beta)","items":[{"type":"link","label":"Introducing the gqlmocks CLI","href":"/docs/cli/introducing-gqlmocks","docId":"cli/introducing-gqlmocks"},{"type":"link","label":"CLI Commands","href":"/docs/cli/commands","docId":"cli/commands"},{"type":"link","label":"Quick Mocking with Serve","href":"/docs/cli/quick-mocking","docId":"cli/quick-mocking"},{"type":"link","label":"gqlmocks Config File","href":"/docs/cli/gqlmocks-config","docId":"cli/gqlmocks-config"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Guides","items":[{"type":"link","label":"Using Paper with graphql-mocks","href":"/docs/guides/paper","docId":"guides/paper"},{"type":"link","label":"Managing Resolver Context","href":"/docs/guides/managing-context","docId":"guides/managing-context"},{"type":"link","label":"Automatic Resolver Filtering with Wrappers","href":"/docs/guides/automatic-filtering","docId":"guides/automatic-filtering"},{"type":"link","label":"Relay Pagination","href":"/docs/guides/relay-pagination","docId":"guides/relay-pagination"},{"type":"link","label":"Automatic Mocking with Fake Data using Falso","href":"/docs/guides/fake-data","docId":"guides/fake-data"},{"type":"link","label":"Mirage JS","href":"/docs/guides/mirage-js","docId":"guides/mirage-js"}],"collapsed":true,"collapsible":true}]},"docs":{"cli/commands":{"id":"cli/commands","title":"CLI Commands","description":"The CLI is packaged as a npm package. The easiest way to use it is via npx and prefixing the cli with npx:","sidebar":"docs"},"cli/gqlmocks-config":{"id":"cli/gqlmocks-config","title":"gqlmocks Config File","description":"The gqlmocks can use a configuration file, gqlmocks.config.js, in the root of a project. The paths and options specified by the gqlmocks config file make it easier to run other commands with specified defaults, and will provide the basis for future options.","sidebar":"docs"},"cli/introducing-gqlmocks":{"id":"cli/introducing-gqlmocks","title":"Introducing the gqlmocks CLI","description":"The gqlmocks makes mocking easy with localhost mocking, setting up configuration defaults, generating file boilerplate, and verifying project setup. It\'s currently in beta as it\'s usage is tested and more integrations are added.","sidebar":"docs"},"cli/quick-mocking":{"id":"cli/quick-mocking","title":"Quick Mocking with Serve","description":"Using the gqlmocks serve command is the fastest way to get mocking only a GraphQL Schema.","sidebar":"docs"},"getting-started/concepts":{"id":"getting-started/concepts","title":"Concepts","description":"These are some concepts and terms you might see when looking to mock your GraphQL API.","sidebar":"docs"},"getting-started/installation":{"id":"getting-started/installation","title":"Installation","description":"Install graphql-mocks along with the graphql peer dependency","sidebar":"docs"},"getting-started/introduction":{"id":"getting-started/introduction","title":"Introduction","description":"GraphQL has proven itself to be a powerful tool in building APIs. A single GraphQL endpoint supports an extremely","sidebar":"docs"},"getting-started/quick-example":{"id":"getting-started/quick-example","title":"Quick Example","description":"This example will show how to:","sidebar":"docs"},"guides/automatic-filtering":{"id":"guides/automatic-filtering","title":"Automatic Resolver Filtering with Wrappers","description":"A common pattern is to filter information on Field Resolvers based on arguments from a query. In the case this pattern can be applied to multiple Field Resolvers it\'s useful to standardize this filtering with Resolver Wrappers. This helps separate filtering from the data resolution and allows for re-use. The nature of the filtering depends on the conventions of your GraphQL API.","sidebar":"docs"},"guides/fake-data":{"id":"guides/fake-data","title":"Automatic Mocking with Fake Data using Falso","description":"Falso is a popular javascript library that provides mocking functions for a variety of types of data across different domains. Using the Falso middleware with graphql-mocks makes it easy to get a fully mocked GraphQL API quickly. This is useful when some data should be mocked concretely, but the other fields can be generated.","sidebar":"docs"},"guides/managing-context":{"id":"guides/managing-context","title":"Managing Resolver Context","description":"Every GraphQL Resolver has a context argument. The graphql-mocks framework manages this context object and provides various entry points to include additional properties on the context object.","sidebar":"docs"},"guides/mirage-js":{"id":"guides/mirage-js","title":"Mirage JS","description":"Mirage JS is a great tool that makes mocking resources backed by RESTful APIs easier. One of the main benefits","sidebar":"docs"},"guides/paper":{"id":"guides/paper","title":"Using Paper with graphql-mocks","description":"GraphQL Paper can be used on its own but has been designed and tested to integrate with graphql-mocks.","sidebar":"docs"},"guides/relay-pagination":{"id":"guides/relay-pagination","title":"Relay Pagination","description":"One of the common ways of paginating in GraphQL is by using \\"Relay Pagnation\\". Relay Pagination is cursor-based and was","sidebar":"docs"},"handler/handler-state":{"id":"handler/handler-state","title":"Handler State","description":"The GraphQLHandler provides a state object that is available within Middlewares, Wrappers, and Resolvers. It is generically available for persisting anything across the duration of an instance of GraphQLHandler.","sidebar":"docs"},"handler/introducing-handler":{"id":"handler/introducing-handler","title":"Introducing the GraphQL Handler","description":"Ultimately, in order to be able to execute GraphQL queries you need a GraphQL handler. This handler accepts a query and variables and returns a payload of data and/or errors.","sidebar":"docs"},"handler/using-middlewares":{"id":"handler/using-middlewares","title":"Using Middlewares","description":"The GraphQLHandler accepts an array of middlewares, chaining together a series of modifications to the Resolver Map (or an empty object if one does not exist). After all the Middlewares have been run the GraphQLHandler takes the final \\"packed\\" Resolver Map and applies each Resolver function to the GraphQLSchema, its types and fields.","sidebar":"docs"},"highlight/available-highlighters":{"id":"highlight/available-highlighters","title":"Available Highlighters","description":"They are used in conjunction with the Highlight system and you can also create your own custom ones. If you\'ve created one that could be useful for the community open up a PR or issue and it can be added either to the graphql-mocks package or linked externally.","sidebar":"docs"},"highlight/creating-highlighters":{"id":"highlight/creating-highlighters","title":"Create Custom Highlighters","description":"Highlighters return highlighted References, that is an array of either Type References or Field References, for a given schema. There are already a number of useful highlighters provided by graphql-mocks out-of-the-box.","sidebar":"docs"},"highlight/introducing-highlight":{"id":"highlight/introducing-highlight","title":"Introducing Highlight","description":"One of the most important parts about mocking a GraphQL API is being able to quickly and effectively target specific parts of the GraphQL Schema. Highlight is a declarative, extensible, system for describing Named Types, and their fields, of the GraphQL Schema. With this type of control it becomes quick to mock specific types and fields and use Highlights in Resolver Map Middlewares and other utilities.","sidebar":"docs"},"network/cypress":{"id":"network/cypress","title":"Cypress","description":"Cypress is a free and open-source JavaScript testing framework for end-to-end, integration, and","sidebar":"docs"},"network/express":{"id":"network/express","title":"Express","description":"Express is a popular node.js web server library. Mocks loaded into a  GraphQLHandler can be integrated with express, via @graphql-mocks/network-express, to provide a live running server. This is useful when needing a live endpoint to test against or hosting mocks to share with others.","sidebar":"docs"},"network/introducing-network-handlers":{"id":"network/introducing-network-handlers","title":"Introducing Network Handlers","description":"GraphQL is network-agnostic and works across any protocol where requests and responses can be sent and received. This flexibility extends to graphql-mocks allowing for writing mocks once and reusing them in node.js, the browser, and with any library that can handle requests and responses.","sidebar":"docs"},"network/msw":{"id":"network/msw","title":"Mock Service Worker","description":"The msw (mock service worker) package is useful in intercepting and mocking requests in the browser. Its use of service workers means requests still appear in the network tab, creating a realistic mocking environment. With @graphql-mocks/network-msw the requests and responses can be handled by msw with a GraphQL handler for full GraphQL mocking in the browser.","sidebar":"docs"},"network/nock":{"id":"network/nock","title":"Nock","description":"Nock is used for testing and mocking http requests in Node. Integrating graphql-mocks with Nock is easy with @graphql-mocks/network-nock.","sidebar":"docs"},"network/pretender":{"id":"network/pretender","title":"Pretender","description":"Pretender is a javascript library for the browser that intercepts network requests made with fetch or XMLHttpRequest. It has a straight-forward syntax for defining routes. Unlike mock service worker, which relies on service workers, pretender patches globals in order to capture requests made. This makes pretender quicker to setup than msw but sacrifices amongst other benefits; being able to see the intercepted requests in the network tab of browser developer tools. Captured network requests from pretender can be logged however (see below).","sidebar":"docs"},"paper/events":{"id":"paper/events","title":"Events","description":"After a Mutate Transaction any relevant events will be dispatched followed by any events that have been queued. This is useful for responding to specific changes either from GraphQL Paper or custom events that might have been queued in a custom operation or by the Mutate Transaction itself using the queueEvent operation.","sidebar":"docs"},"paper/guides/factories":{"id":"paper/guides/factories","title":"Generating Data with Factories","description":"Note: A better factory operation is in the works but while the api is being ironed out, this works as a great option that can be migrated later.","sidebar":"docs"},"paper/guides/managing-ids":{"id":"paper/guides/managing-ids","title":"Managing IDs","description":"IDs that exist as scalars on a GraphQL Schema are considered part of the data of a Document. GraphQL Paper doesn\'t use them for tracking uniqueness although it does have ways of helping ensure that data for ID fields are kept unique and also help in generating ID values.","sidebar":"docs"},"paper/guides/with-graphql":{"id":"paper/guides/with-graphql","title":"Using GraphQL Paper with GraphQL","description":"GraphQL Paper is built on the core graphql library and works well with its default resolvers. GraphQL Paper should also work well with other javascript systems that use resolver functions, too. The best integrations will still be with graphql-mocks and its packages which are designed and tested together.","sidebar":"docs"},"paper/hooks":{"id":"paper/hooks","title":"Hooks","description":"Creating Custom Hooks","sidebar":"docs"},"paper/installation":{"id":"paper/installation","title":"Installation","description":"Installation","sidebar":"docs"},"paper/introducing-paper":{"id":"paper/introducing-paper","title":"Introducing GraphQL Paper","description":"GraphQL Paper is a flexible in-memory store based on a provided GraphQL Schema.","sidebar":"docs"},"paper/mutating-data":{"id":"paper/mutating-data","title":"Mutating Data","description":"Data in the store is always mutated via the mutate method on a Paper instance by passing in a Mutation Transaction callback. Within the Mutation Transaction callback there are several operations available to support being able to make changes easily to the store, even custom ones can be added.","sidebar":"docs"},"paper/operations":{"id":"paper/operations","title":"Operations","description":"Operations are functions available within an Mutate Transaction callback with access to internal context including the current mutable version of the DocumentStore being operated on.","sidebar":"docs"},"paper/querying-data":{"id":"paper/querying-data","title":"Querying Data","description":"There are a few different ways to retrieve data from a Paper instance.","sidebar":"docs"},"paper/technical-notes":{"id":"paper/technical-notes","title":"Technical Notes","description":"Storage & Immutability","sidebar":"docs"},"paper/validations":{"id":"paper/validations","title":"Validations","description":"Validations are a powerful feature that keep the DocumentStore in check and maintain consistency after every transaction. They flexibly describe and define the set of rules to which the Document Store must conform to.","sidebar":"docs"},"resolver-map/available-middlewares":{"id":"resolver-map/available-middlewares","title":"Available Middlewares","description":"There are many useful Resolver Map Middlewares available to quickly mock and augment GraphQL APIs. Learn how to create your own custom middlewares. Have a useful Resolver Map Middleware to share with the community? Open a PR to add it here.","sidebar":"docs"},"resolver-map/creating-middlewares":{"id":"resolver-map/creating-middlewares","title":"Creating Custom Middlewares","description":"Anatomy of a Resolver Map Middleware","sidebar":"docs"},"resolver-map/introducing-middlewares":{"id":"resolver-map/introducing-middlewares","title":"Introducing Resolver Map Middlewares","description":"A Resolver Map is the base layer for organizing Resolvers against a GraphQL Schema for execution. The ability to lazily","sidebar":"docs"},"resolver-map/managing-resolvers":{"id":"resolver-map/managing-resolvers","title":"Managing Resolvers with Middlewares","description":"Adding and Managing Resolvers on a Resolver Map is a common task when setting up different scenarios. This library provides two Resolver Map Middleware functions to make this easy, embed and layer, both which can apply Resolver Wrappers.","sidebar":"docs"},"resolver-map/using-resolver-maps":{"id":"resolver-map/using-resolver-maps","title":"Using Resolver Maps","description":"After learning how to use Resolvers to resolve data all that is left to organize them","sidebar":"docs"},"resolver/applying-wrappers":{"id":"resolver/applying-wrappers","title":"Applying Wrappers","description":"The most common way of using Resolver Wrappers is with the embed Resolver Map Middleware function which can return a","sidebar":"docs"},"resolver/available-wrappers":{"id":"resolver/available-wrappers","title":"Available Wrappers","description":"The following is a list of Resolver Wrappers. If you create one that could be useful for the community please open an","sidebar":"docs"},"resolver/creating-wrappers":{"id":"resolver/creating-wrappers","title":"Creating Custom Wrappers","description":"As previously shown, a Resolver Wrapper is a function that receives a Resolver and must return a Resolver. This design","sidebar":"docs"},"resolver/introducing-wrappers":{"id":"resolver/introducing-wrappers","title":"Introducing Resolver Wrappers","description":"A Resolver Wrapper in its most basic form is a function that receives a Resolver function and returns a Resolver function. The returned Resolver function wraps the original and allows the result to be extracted and conditionally extended.","sidebar":"docs"},"resolver/using-resolvers":{"id":"resolver/using-resolvers","title":"Using Resolvers","description":"Resolvers are functions that make up the basis for how data is determined in resolving queries in GraphQL APIs. There","sidebar":"docs"}}}')}}]);