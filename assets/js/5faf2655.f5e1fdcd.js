"use strict";(self.webpackChunk_graphql_mocks_docs=self.webpackChunk_graphql_mocks_docs||[]).push([[4961],{26109:function(e,r,t){t.r(r),t.d(r,{assets:function(){return c},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return u}});var n=t(28427),a=t(84397),p=(t(2784),t(30876)),o=["components"],i={id:"creating-wrappers",title:"Creating Custom Wrappers"},l=void 0,s={unversionedId:"resolver/creating-wrappers",id:"resolver/creating-wrappers",title:"Creating Custom Wrappers",description:"As previously shown, a Resolver Wrapper is a function that receives a Resolver and must return a Resolver. This design",source:"@site/docs/resolver/creating-wrappers.md",sourceDirName:"resolver",slug:"/resolver/creating-wrappers",permalink:"/docs/resolver/creating-wrappers",draft:!1,tags:[],version:"current",frontMatter:{id:"creating-wrappers",title:"Creating Custom Wrappers"},sidebar:"docs",previous:{title:"Available Wrappers",permalink:"/docs/resolver/available-wrappers"},next:{title:"Using Resolver Maps",permalink:"/docs/resolver-map/using-resolver-maps"}},c={},u=[{value:"<code>wrapperOptions</code>",id:"wrapperoptions",level:2},{value:"<code>createWrapper</code>",id:"createwrapper",level:2},{value:"<code>createWrapper</code> Arguments",id:"createwrapper-arguments",level:3},{value:"Generic Resolver Wrapper",id:"generic-resolver-wrapper",level:2}],d={toc:u};function m(e){var r=e.components,t=(0,a.Z)(e,o);return(0,p.kt)("wrapper",(0,n.Z)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"As previously shown, a Resolver Wrapper is a function that receives a Resolver and must return a Resolver. This design\nallows for a returned Resolver function that wraps the original. The original resolver can be ",(0,p.kt)("inlineCode",{parentName:"p"},"await"),"ed for a result,\nthe arguments can be checked, changed, same with the final returned result.\nThe Generic Resolver Wrapper shows the basic concept but it is recommended to use the ",(0,p.kt)("inlineCode",{parentName:"p"},"createWrapper")," function."),(0,p.kt)("h2",{id:"wrapperoptions"},(0,p.kt)("inlineCode",{parentName:"h2"},"wrapperOptions")),(0,p.kt)("p",null,"Whether using ",(0,p.kt)("inlineCode",{parentName:"p"},"createWrapper")," or the Generic Wrapper Function are passed ",(0,p.kt)("inlineCode",{parentName:"p"},"wrapperOptions"),". ",(0,p.kt)("inlineCode",{parentName:"p"},"wrapperOptions")," includes useful contextual details about the Resolver being wrapped. Including ",(0,p.kt)("inlineCode",{parentName:"p"},"wrapperOptions.type"),"\nfor the GraphQL type and ",(0,p.kt)("inlineCode",{parentName:"p"},"wrapperOptions.field")," if it is wrapping a Field Resolver."),(0,p.kt)("h2",{id:"createwrapper"},(0,p.kt)("inlineCode",{parentName:"h2"},"createWrapper")),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",{parentName:"li",href:"pathname:///api/graphql-mocks/modules/resolver.html#createWrapper"},"API"))),(0,p.kt)("p",null,"Using ",(0,p.kt)("inlineCode",{parentName:"p"},"createWrapper")," helps by providing more context about the wrapper and includes the following benefits:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},"The wrapper is named which helps in debugging through multiple wrappers"),(0,p.kt)("li",{parentName:"ul"},"The second argument will apply the right typescript typing for ",(0,p.kt)("inlineCode",{parentName:"li"},"originalResolver")," and ",(0,p.kt)("inlineCode",{parentName:"li"},"wrapperOptions")),(0,p.kt)("li",{parentName:"ul"},"There are runtime checks to ensure that the type specified by second argument match the resolver being wrapped")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},"import { createWrapper, WrapperFor } from 'graphql-mocks/resolver';\n\nconst wrapper = createWrapper('my-wrapper', WrapperFor.FIELD, function(originalResolver, wrapperOptions) {\n  return async function(parent, args, context, info) {\n    console.log('Inside the wrapper');\n\n    // Awaiting the result of the original using the parameters\n    // passed in from the wrapped resolver\n    const result = await originalResolver(parent, args, context, info);\n\n    console.log(\"Returning original resolver result\", result);\n    return result;\n  };\n});\n")),(0,p.kt)("h3",{id:"createwrapper-arguments"},(0,p.kt)("inlineCode",{parentName:"h3"},"createWrapper")," Arguments"),(0,p.kt)("table",null,(0,p.kt)("thead",{parentName:"table"},(0,p.kt)("tr",{parentName:"thead"},(0,p.kt)("th",{parentName:"tr",align:null},"Argument"),(0,p.kt)("th",{parentName:"tr",align:null},"From the Example"),(0,p.kt)("th",{parentName:"tr",align:null},"Description"))),(0,p.kt)("tbody",{parentName:"table"},(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"Name"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("inlineCode",{parentName:"td"},"my-wrapper")),(0,p.kt)("td",{parentName:"tr",align:null},"Provides the name of the wrapper")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"WrapperFor"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("inlineCode",{parentName:"td"},"WrapperFor.FIELD")),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("inlineCode",{parentName:"td"},"WrapperFor.FIELD"),", ",(0,p.kt)("inlineCode",{parentName:"td"},"WrapperFor.TYPE"),", ",(0,p.kt)("inlineCode",{parentName:"td"},"WrapperFor.ANY"),". The constant that specifies the type of Resolver the wrapper can apply to. ",(0,p.kt)("inlineCode",{parentName:"td"},"WrapperFor.ANY")," can be used if the Wrapper can be used for both Type Resolvers and Field Resolvers.")),(0,p.kt)("tr",{parentName:"tbody"},(0,p.kt)("td",{parentName:"tr",align:null},"Wrapper Function"),(0,p.kt)("td",{parentName:"tr",align:null},(0,p.kt)("em",{parentName:"td"},"see function in example")),(0,p.kt)("td",{parentName:"tr",align:null},"The Resolver Wrapper function. The ",(0,p.kt)("inlineCode",{parentName:"td"},"originalResolver")," and ",(0,p.kt)("inlineCode",{parentName:"td"},"wrapperOptions")," will be typed based on the ",(0,p.kt)("inlineCode",{parentName:"td"},"WrapperFor")," constant.")))),(0,p.kt)("h2",{id:"generic-resolver-wrapper"},"Generic Resolver Wrapper"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("a",{parentName:"li",href:"pathname:///api/graphql-mocks/modules/resolver.types.html#GenericWrapperFunction"},"API"))),(0,p.kt)("p",null,(0,p.kt)("strong",{parentName:"p"},"Note: While this is a valid Resolver Wrapper Function it is recommended to use the ",(0,p.kt)("a",{parentName:"strong",href:"#createwrapper"},(0,p.kt)("inlineCode",{parentName:"a"},"createWrapper"))," for most cases")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},"const wrapper = function (originalResolver, wrapperOptions) {\n  return async function (parent, args, context, info) {\n    console.log('Inside the wrapper');\n\n    // Awaiting the result of the original using the parameters\n    // passed in from the wrapped resolver\n    const result = await originalResolver(parent, args, context, info);\n\n    console.log(\"Returning original resolver result\", result);\n    return result;\n  }\n}\n")),(0,p.kt)("p",null,"As we have seen in the ",(0,p.kt)("a",{parentName:"p",href:"/docs/resolver/using-resolvers"},"Using Resolver")," there are two types of Resolvers: Field\nResolvers and Type Resolvers. Both can be wrapped but it's important to note the arguments to these two Resolver\nfunctions are different. Therefore, there are some Resolver Wrappers that can only be used for Field Resolvers, or Type Resolvers. To make this easier it is recommended to use the ",(0,p.kt)("inlineCode",{parentName:"p"},"createWrapper")," helper which provides additional type checks and guards at runtime."))}m.isMDXComponent=!0},30876:function(e,r,t){t.d(r,{Zo:function(){return c},kt:function(){return m}});var n=t(2784);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function p(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?p(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},p=Object.keys(e);for(n=0;n<p.length;n++)t=p[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(n=0;n<p.length;n++)t=p[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=n.createContext({}),s=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},c=function(e){var r=s(e.components);return n.createElement(l.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},d=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,p=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=s(t),m=a,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||p;return t?n.createElement(h,o(o({ref:r},c),{},{components:t})):n.createElement(h,o({ref:r},c))}));function m(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var p=t.length,o=new Array(p);o[0]=d;var i={};for(var l in r)hasOwnProperty.call(r,l)&&(i[l]=r[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var s=2;s<p;s++)o[s]=t[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);