"use strict";(self.webpackChunk_graphql_mocks_docs=self.webpackChunk_graphql_mocks_docs||[]).push([[4941],{5141:function(e,t,n){n.d(t,{u:function(){return a}});var r=n(2784);function a(e){return r.createElement(r.Fragment,null,r.createElement("strong",null,"Result: "),r.createElement("pre",{className:"graphql-result"},JSON.stringify(e.result,null,2)))}},50339:function(e,t,n){n.r(t),n.d(t,{assets:function(){return w},contentTitle:function(){return k},default:function(){return T},frontMatter:function(){return v},metadata:function(){return b},toc:function(){return x}});var r=n(28427),a=n(84397),i=(n(2784),n(30876)),o=n(5141),l={data:{movies:[{title:"Spirited Away",year:"2001"},{title:"Shrek",year:"2001"}]}},s=["components"],p={toc:[]};function u(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { createWrapper, WrapperFor } from "graphql-mocks/resolver";\n\nfunction filterResult(result, args) {\n  // only filter on results that are arrays of objects, ie: [User!]!\n  if (\n    !Array.isArray(result) ||\n    (Array.isArray(result) && result.some((item) => typeof item !== "object"))\n  ) {\n    return result;\n  }\n\n  const filtered = result.filter((resultItem) => {\n    // ensure that the value for an argument matches the value\n    // on the object for the matching key\n    return Object.entries(args).every(([key, value]) => {\n      if (key in resultItem) {\n        return resultItem[key] === value;\n      }\n\n      return true;\n    });\n  });\n\n  return filtered;\n}\n\nexport const automaticFilterWrapper = createWrapper(\n  "automatic-field-filtering",\n  WrapperFor.FIELD,\n  async function (originalResolver, wrapperOptions) {\n    return async (parent, args, context, info) => {\n      const result = await originalResolver(parent, args, context, info);\n      return filterResult(result, args);\n    };\n  }\n);\n')))}u.isMDXComponent=!0;var c=["components"],m={toc:[]};function f(e){var t=e.components,n=(0,a.Z)(e,c);return(0,i.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'export const movies = [\n  {\n    title: "Spirited Away",\n    year: "2001",\n  },\n\n  {\n    title: "Shrek",\n    year: "2001",\n  },\n\n  {\n    title: "La La Land",\n    year: "2016",\n  },\n];\n')))}f.isMDXComponent=!0;var d=["components"],y={toc:[]};function g(e){var t=e.components,n=(0,a.Z)(e,d);return(0,i.kt)("wrapper",(0,r.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { GraphQLHandler } from "graphql-mocks";\nimport { embed } from "graphql-mocks/resolver-map";\nimport { automaticFilterWrapper } from "./automatic-filtering-filter.source";\nimport { resolverMap } from "./resolver-map";\n\nconst handler = new GraphQLHandler({\n  resolverMap,\n  middlewares: [\n    embed({\n      wrappers: [automaticFilterWrapper],\n    }),\n  ],\n\n  dependencies: {\n    graphqlSchema: `\n      schema {\n        query: Query\n      }\n\n      type Query {\n        movies(title: String, year: String): [Movie!]!\n      }\n\n      type Movie {\n        title: String!\n        year: String!\n      }\n    `,\n  },\n});\n\nconst query = handler.query(\n  `\n  query FilteredMovies($year: String) {\n    movies(year: $year) {\n      title\n      year\n    }\n  }\n`,\n  {\n    year: "2001",\n  }\n);\nquery.then((result) => console.log(result));\n')))}g.isMDXComponent=!0;var h=["components"],v={title:"Automatic Resolver Filtering with Wrappers"},k=void 0,b={unversionedId:"guides/automatic-filtering",id:"guides/automatic-filtering",title:"Automatic Resolver Filtering with Wrappers",description:"A common pattern is to filter information on Field Resolvers based on arguments from a query. In the case this pattern can be applied to multiple Field Resolvers it's useful to standardize this filtering with Resolver Wrappers. This helps separate filtering from the data resolution and allows for re-use. The nature of the filtering depends on the conventions of your GraphQL API.",source:"@site/docs/guides/automatic-filtering.mdx",sourceDirName:"guides",slug:"/guides/automatic-filtering",permalink:"/docs/guides/automatic-filtering",draft:!1,tags:[],version:"current",frontMatter:{title:"Automatic Resolver Filtering with Wrappers"},sidebar:"docs",previous:{title:"Managing Resolver Context",permalink:"/docs/guides/managing-context"},next:{title:"Relay Pagination",permalink:"/docs/guides/relay-pagination"}},w={},x=[{value:"Example",id:"example",level:2}],O={toc:x};function T(e){var t=e.components,n=(0,a.Z)(e,h);return(0,i.kt)("wrapper",(0,r.Z)({},O,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A common pattern is to filter information on Field Resolvers based on arguments from a query. In the case this pattern can be applied to multiple Field Resolvers it's useful to standardize this filtering with ",(0,i.kt)("a",{parentName:"p",href:"/docs/resolver/introducing-wrappers"},"Resolver Wrappers"),". This helps separate filtering from the data resolution and allows for re-use. The nature of the filtering depends on the conventions of your GraphQL API."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"This Resolver Wrapper is an example of automatically filtering a list based on the arguments passed in. If a given key is provided it will filter any list down based on the value of the argument."),(0,i.kt)(u,{mdxType:"AutomaticFilterSource"}),(0,i.kt)("p",null,"For this example the ",(0,i.kt)("inlineCode",{parentName:"p"},"Query.movies")," resolver has the following data:"),(0,i.kt)(f,{mdxType:"AutomaticFilterData"}),(0,i.kt)("p",null,"Then setting up the handler to apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"automaticFilter")," Wrapper against the ",(0,i.kt)("inlineCode",{parentName:"p"},"Query.movies"),"\nfield resolver. The ",(0,i.kt)("inlineCode",{parentName:"p"},"highlight")," argument can be customized to specify a specific selection of fields that should receive the automatic filter wrapper. Also, because there can be multiple Resolver Wrappers passed into the ",(0,i.kt)("inlineCode",{parentName:"p"},"wrappers")," array, you could crete and combine multiple automatic filtering Field Wrappers to flexibly compose filtering across your fields."),(0,i.kt)("p",null,"The final query in the example, ",(0,i.kt)("inlineCode",{parentName:"p"},"FilteredMovies"),", will automatically filter based on the query args ",(0,i.kt)("inlineCode",{parentName:"p"},'{ "year": "2001" }')," since ",(0,i.kt)("inlineCode",{parentName:"p"},"year")," is an argument that also exists on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Movie")," type being filtered."),(0,i.kt)(g,{mdxType:"AutomaticFilterExample"}),(0,i.kt)(o.u,{result:l,mdxType:"GraphQLResult"}),(0,i.kt)("p",null,'In the result the movie "La La Land" was filtered out since it was released in 2016 and the query specified movies with the year ',(0,i.kt)("inlineCode",{parentName:"p"},"'2001'"),"."))}T.isMDXComponent=!0},30876:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return f}});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),f=a,d=m["".concat(s,".").concat(f)]||m[f]||c[f]||i;return n?r.createElement(d,o(o({ref:t},u),{},{components:n})):r.createElement(d,o({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);