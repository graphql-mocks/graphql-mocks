(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{111:function(e,n,r){"use strict";r.d(n,"a",(function(){return o}));var t=r(0),a=r.n(t);function o(e){return a.a.createElement(a.a.Fragment,null,a.a.createElement("strong",null,"Result: "),a.a.createElement("pre",{className:"graphql-result"},JSON.stringify(e.result,null,2)))}},206:function(e,n,r){"use strict";n.a={data:{helloWorld:"Hello from my first GraphQL resolver!"}}},86:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return c})),r.d(n,"metadata",(function(){return p})),r.d(n,"rightToc",(function(){return u})),r.d(n,"default",(function(){return h}));var t=r(2),a=(r(0),r(89));const o={rightToc:[]};function i({components:e,...n}){return Object(a.b)("wrapper",Object(t.a)({},o,n,{components:e,mdxType:"MDXLayout"}),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),'function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);\n      }\n      _next(undefined);\n    });\n  };\n} // This example is assuming you already have a GraphQL resolver map and have an\n// existing handler (in this case via graphql-tools). If this is not the case\n// check out the "Creating a GraphQL Handler" documentation section to create a GraphQL\n// handler with `graphql-mocks`.\nimport { makeExecutableSchema } from "graphql-tools";\nimport { buildSchema, graphql, printSchema } from "graphql";\nimport { pack } from "graphql-mocks/pack";\nfunction run() {\n  return _run.apply(this, arguments);\n}\n\n// kick everything off\nfunction _run() {\n  _run = _asyncToGenerator(\n    /*#__PURE__*/ regeneratorRuntime.mark(function _callee() {\n      var graphqlSchema,\n        resolverMap,\n        middlewares,\n        dependencies,\n        packed,\n        packedResolverMap,\n        executableSchema,\n        result;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch ((_context.prev = _context.next)) {\n            case 0:\n              graphqlSchema = buildSchema(\n                "\\n    schema {\\n      query: Query\\n    }\\n\\n    type Query {\\n      helloWorld: String!\\n    }\\n  "\n              ); // This represents the original resolver map being used by your existing GraphQL\n              // handler and is needed for the `pack` function to apply Resolver Map\n              // Middlewares and Resolver Wrappers.\n              resolverMap = {\n                Query: {\n                  helloWorld: function helloWorld() {\n                    return "Hello from my first GraphQL resolver!";\n                  },\n                },\n              }; // using an array of middlewares to apply\n              middlewares = []; // any dependencies that might be required by the Resolver Map Middlewares or\n              // Resolver Wrappers. `graphqlSchema` is a required dependency;\n              dependencies = { graphqlSchema: graphqlSchema };\n              _context.next = 6;\n              return pack(resolverMap, middlewares, {\n                dependencies: dependencies,\n              });\n            case 6:\n              packed = _context.sent; // the packed result includes a `resolverMap` field that would have applied any\n              // middlewares. These can then be applied in place of where you would have used\n              // your previous resolverMap\n              packedResolverMap = packed.resolverMap; // `makeExecutableSchema` is how graphql-tools creates applies a Resolver Map\n              // to a Schema so that it can accept queries\n              executableSchema = makeExecutableSchema({\n                typeDefs: printSchema(graphqlSchema), // BEFORE using `graphql-mocks` this would have uses the original resolver map\n                // resolvers: resolverMap,\n                // AFTER, it uses the packed Resolver Map which includes the application of\n                // Resolver Map Middlewares and any Resolver Wrappers\n                resolvers: packedResolverMap,\n              });\n              _context.next = 11;\n              return graphql(\n                executableSchema,\n                "\\n      query {\\n        helloWorld\\n      }\\n    "\n              );\n            case 11:\n              result = _context.sent;\n              return _context.abrupt("return", result);\n            case 13:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    })\n  );\n  return _run.apply(this, arguments);\n}\nrun();\n')))}i.isMDXComponent=!0;var l=r(206),s=r(111);const c={id:"pack",title:"Manually Apply Middlewares"},p={unversionedId:"guides/pack",id:"guides/pack",isDocsHomePage:!1,title:"Manually Apply Middlewares",description:"import",source:"@site/docs/guides/pack.mdx",slug:"/guides/pack",permalink:"/docs/guides/pack",version:"current",sidebar:"docs",previous:{title:"Mirage JS",permalink:"/docs/guides/mirage-js"}},u=[{value:"Using <code>pack</code> with an Existing GraphQL Handler",id:"using-pack-with-an-existing-graphql-handler",children:[]}],d={rightToc:u};function h({components:e,...n}){return Object(a.b)("wrapper",Object(t.a)({},d,n,{components:e,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"pack")," function can be used to manually apply Resolver Map Middlewares to Resolver Maps. This is especially useful\nwith an existing GraphQL Handler is already setup with a Resolver Map."),Object(a.b)("h2",{id:"using-pack-with-an-existing-graphql-handler"},"Using ",Object(a.b)("inlineCode",{parentName:"h2"},"pack")," with an Existing GraphQL Handler"),Object(a.b)("p",null,"If you are getting started and haven't set up a GraphQL handler yet, it is easier to use the library's GraphQL handler\n",Object(a.b)("a",Object(t.a)({parentName:"p"},{href:"../getting-started/create-handler"}),"create a GraphQL handler")," instead."),Object(a.b)("p",null,"Otherwise, if you already have a handler set up you most likely can still use it with this library if you have a\nResolver Map. This library provides a ",Object(a.b)("inlineCode",{parentName:"p"},"pack")," function which takes an initial Resolver Map and applies operations against\nit using Resolver Map Middlewares. The result of ",Object(a.b)("inlineCode",{parentName:"p"},"pack"),' is a new "packed" Resolver Map that can now be used in your\nexisting GraphQL handler.'),Object(a.b)("p",null,"Here is an example that uses the third-party package, ",Object(a.b)("inlineCode",{parentName:"p"},"graphql-tools"),", and its handler."),Object(a.b)(i,{mdxType:"ExistingHandlerExample"}),Object(a.b)(s.a,{result:l.a,mdxType:"GraphQLResult"}))}h.isMDXComponent=!0},89:function(e,n,r){"use strict";r.d(n,"a",(function(){return u})),r.d(n,"b",(function(){return m}));var t=r(0),a=r.n(t);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=a.a.createContext({}),p=function(e){var n=a.a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},u=function(e){var n=p(e.components);return a.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},h=a.a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),h=t,m=u["".concat(i,".").concat(h)]||u[h]||d[h]||o;return r?a.a.createElement(m,l(l({ref:n},c),{},{components:r})):a.a.createElement(m,l({ref:n},c))}));function m(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=r.length,i=new Array(o);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:t,i[1]=l;for(var c=2;c<o;c++)i[c]=r[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,r)}h.displayName="MDXCreateElement"}}]);